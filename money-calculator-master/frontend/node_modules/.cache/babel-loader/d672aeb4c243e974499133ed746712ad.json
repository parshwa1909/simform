{"ast":null,"code":"!function (t) {\n  \"function\" == typeof define && define.amd ? define(t) : t();\n}(function () {\n  \"use strict\";\n\n  function t() {}\n\n  function e(t) {\n    return t();\n  }\n\n  function n() {\n    return Object.create(null);\n  }\n\n  function o(t) {\n    t.forEach(e);\n  }\n\n  function i(t) {\n    return \"function\" == typeof t;\n  }\n\n  function r(t, e) {\n    return t != t ? e == e : t !== e || t && \"object\" == typeof t || \"function\" == typeof t;\n  }\n\n  function s(t, e) {\n    return t != t ? e == e : t !== e;\n  }\n\n  function c(t) {\n    return 0 === Object.keys(t).length;\n  }\n\n  function a(t, e) {\n    t.appendChild(e);\n  }\n\n  function l(t, e, n) {\n    const o = function (t) {\n      if (!t) return document;\n      const e = t.getRootNode ? t.getRootNode() : t.ownerDocument;\n      if (e && e.host) return e;\n      return t.ownerDocument;\n    }(t);\n\n    if (!o.getElementById(e)) {\n      const t = f(\"style\");\n      t.id = e, t.textContent = n, function (t, e) {\n        a(t.head || t, e);\n      }(o, t);\n    }\n  }\n\n  function d(t, e, n) {\n    t.insertBefore(e, n || null);\n  }\n\n  function u(t) {\n    t.parentNode.removeChild(t);\n  }\n\n  function f(t) {\n    return document.createElement(t);\n  }\n\n  function h(t) {\n    return document.createElementNS(\"http://www.w3.org/2000/svg\", t);\n  }\n\n  function p(t) {\n    return document.createTextNode(t);\n  }\n\n  function g() {\n    return p(\" \");\n  }\n\n  function $(t, e, n, o) {\n    return t.addEventListener(e, n, o), () => t.removeEventListener(e, n, o);\n  }\n\n  function m(t, e, n) {\n    null == n ? t.removeAttribute(e) : t.getAttribute(e) !== n && t.setAttribute(e, n);\n  }\n\n  function v(t, e, n, o) {\n    t.style.setProperty(e, n, o ? \"important\" : \"\");\n  }\n\n  function x(t, e, n) {\n    t.classList[n ? \"add\" : \"remove\"](e);\n  }\n\n  function w(t) {\n    const e = {};\n\n    for (const n of t) e[n.name] = n.value;\n\n    return e;\n  }\n\n  let b;\n\n  function y(t) {\n    b = t;\n  }\n\n  function k() {\n    if (!b) throw new Error(\"Function called outside component initialization\");\n    return b;\n  }\n\n  const z = [],\n        E = [],\n        M = [],\n        _ = [],\n        C = Promise.resolve();\n  let N = !1;\n\n  function D(t) {\n    M.push(t);\n  }\n\n  let B = !1;\n  const F = new Set();\n\n  function S() {\n    if (!B) {\n      B = !0;\n\n      do {\n        for (let t = 0; t < z.length; t += 1) {\n          const e = z[t];\n          y(e), L(e.$$);\n        }\n\n        for (y(null), z.length = 0; E.length;) E.pop()();\n\n        for (let t = 0; t < M.length; t += 1) {\n          const e = M[t];\n          F.has(e) || (F.add(e), e());\n        }\n\n        M.length = 0;\n      } while (z.length);\n\n      for (; _.length;) _.pop()();\n\n      N = !1, B = !1, F.clear();\n    }\n  }\n\n  function L(t) {\n    if (null !== t.fragment) {\n      t.update(), o(t.before_update);\n      const e = t.dirty;\n      t.dirty = [-1], t.fragment && t.fragment.p(t.ctx, e), t.after_update.forEach(D);\n    }\n  }\n\n  const A = new Set();\n\n  function R(t, e) {\n    t && t.i && (A.delete(t), t.i(e));\n  }\n\n  function I(t, e, n, o) {\n    if (t && t.o) {\n      if (A.has(t)) return;\n      A.add(t), undefined.c.push(() => {\n        A.delete(t), o && (n && t.d(1), o());\n      }), t.o(e);\n    }\n  }\n\n  const P = \"undefined\" != typeof window ? window : \"undefined\" != typeof globalThis ? globalThis : global;\n\n  function T(t) {\n    t && t.c();\n  }\n\n  function V(t, n, r, s) {\n    const {\n      fragment: c,\n      on_mount: a,\n      on_destroy: l,\n      after_update: d\n    } = t.$$;\n    c && c.m(n, r), s || D(() => {\n      const n = a.map(e).filter(i);\n      l ? l.push(...n) : o(n), t.$$.on_mount = [];\n    }), d.forEach(D);\n  }\n\n  function G(t, e) {\n    const n = t.$$;\n    null !== n.fragment && (o(n.on_destroy), n.fragment && n.fragment.d(e), n.on_destroy = n.fragment = null, n.ctx = []);\n  }\n\n  function H(t, e) {\n    -1 === t.$$.dirty[0] && (z.push(t), N || (N = !0, C.then(S)), t.$$.dirty.fill(0)), t.$$.dirty[e / 31 | 0] |= 1 << e % 31;\n  }\n\n  function j(e, i, r, s, c, a, l) {\n    let d = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [-1];\n    const f = b;\n    y(e);\n    const h = e.$$ = {\n      fragment: null,\n      ctx: null,\n      props: a,\n      update: t,\n      not_equal: c,\n      bound: n(),\n      on_mount: [],\n      on_destroy: [],\n      on_disconnect: [],\n      before_update: [],\n      after_update: [],\n      context: new Map(i.context || (f ? f.$$.context : [])),\n      callbacks: n(),\n      dirty: d,\n      skip_bound: !1,\n      root: i.target || f.$$.root\n    };\n    l && l(h.root);\n    let p = !1;\n\n    if (h.ctx = r ? r(e, i.props || {}, function (t, n) {\n      const i = (arguments.length <= 2 ? 0 : arguments.length - 2) ? arguments.length <= 2 ? undefined : arguments[2] : n;\n      return h.ctx && c(h.ctx[t], h.ctx[t] = i) && (!h.skip_bound && h.bound[t] && h.bound[t](i), p && H(e, t)), n;\n    }) : [], h.update(), p = !0, o(h.before_update), h.fragment = !!s && s(h.ctx), i.target) {\n      if (i.hydrate) {\n        const t = function (t) {\n          return Array.from(t.childNodes);\n        }(i.target);\n\n        h.fragment && h.fragment.l(t), t.forEach(u);\n      } else h.fragment && h.fragment.c();\n\n      i.intro && R(e.$$.fragment), V(e, i.target, i.anchor, i.customElement), S();\n    }\n\n    y(f);\n  }\n\n  let O;\n  \"function\" == typeof HTMLElement && (O = class extends HTMLElement {\n    constructor() {\n      super(), this.attachShadow({\n        mode: \"open\"\n      });\n    }\n\n    connectedCallback() {\n      const {\n        on_mount: t\n      } = this.$$;\n      this.$$.on_disconnect = t.map(e).filter(i);\n\n      for (const t in this.$$.slotted) this.appendChild(this.$$.slotted[t]);\n    }\n\n    attributeChangedCallback(t, e, n) {\n      this[t] = n;\n    }\n\n    disconnectedCallback() {\n      o(this.$$.on_disconnect);\n    }\n\n    $destroy() {\n      G(this, 1), this.$destroy = t;\n    }\n\n    $on(t, e) {\n      const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);\n      return n.push(e), () => {\n        const t = n.indexOf(e);\n        -1 !== t && n.splice(t, 1);\n      };\n    }\n\n    $set(t) {\n      this.$$set && !c(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);\n    }\n\n  });\n\n  class U {\n    $destroy() {\n      G(this, 1), this.$destroy = t;\n    }\n\n    $on(t, e) {\n      const n = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);\n      return n.push(e), () => {\n        const t = n.indexOf(e);\n        -1 !== t && n.splice(t, 1);\n      };\n    }\n\n    $set(t) {\n      this.$$set && !c(t) && (this.$$.skip_bound = !0, this.$$set(t), this.$$.skip_bound = !1);\n    }\n\n  }\n\n  function q(t) {\n    l(t, \"svelte-1mwhwtl\", \".Frame.svelte-1mwhwtl{position:absolute;width:100%;height:100%;top:50%;left:50%;transform-origin:50% 50%;transform:translate(-50%, -50%) rotate(var(--fx-rotation));transition:width 0.1s, height 0.1s;pointer-events:none;user-select:none}\");\n  }\n\n  function W(e) {\n    let n, o, i, r, s, c, l;\n    return {\n      c() {\n        n = h(\"svg\"), o = h(\"defs\"), i = h(\"linearGradient\"), r = h(\"stop\"), s = h(\"stop\"), c = h(\"circle\"), l = h(\"circle\"), m(r, \"stop-color\", \"var(--gradient-stop1)\"), m(r, \"offset\", \"0%\"), m(s, \"stop-color\", \"var(--gradient-stop2)\"), m(s, \"offset\", \"100%\"), m(i, \"x1\", \"50%\"), m(i, \"y1\", \"0%\"), m(i, \"x2\", \"50%\"), m(i, \"y2\", \"100%\"), m(i, \"id\", \"a\"), m(c, \"cx\", \"46\"), m(c, \"cy\", \"46\"), m(c, \"r\", e[0]), m(c, \"stroke\", \"none\"), m(c, \"fill\", \"var(--frame-background)\"), m(l, \"cx\", \"46\"), m(l, \"cy\", \"46\"), m(l, \"r\", e[0]), m(l, \"stroke\", \"url(#a)\"), m(l, \"stroke-width\", \"var(--frame-stroke-width)\"), m(l, \"fill\", \"none\"), m(n, \"class\", \"Frame svelte-1mwhwtl\"), m(n, \"viewBox\", \"0 0 92 92\"), m(n, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      },\n\n      m(t, e) {\n        d(t, n, e), a(n, o), a(o, i), a(i, r), a(i, s), a(n, c), a(n, l);\n      },\n\n      p(t, _ref) {\n        let [e] = _ref;\n        1 & e && m(c, \"r\", t[0]), 1 & e && m(l, \"r\", t[0]);\n      },\n\n      i: t,\n      o: t,\n\n      d(t) {\n        t && u(n);\n      }\n\n    };\n  }\n\n  function J(t, e, n) {\n    let {\n      frameRadius: o = 46\n    } = e;\n    return t.$$set = t => {\n      \"frameRadius\" in t && n(0, o = t.frameRadius);\n    }, [o];\n  }\n\n  class K extends U {\n    constructor(t) {\n      super(), j(this, t, J, W, r, {\n        frameRadius: 0\n      }, q);\n    }\n\n  }\n\n  var Q, X, Y, Z, tt, et, nt;\n  !function (t) {\n    t[t.Failed = 0] = \"Failed\", t[t.NoBrowserSupport = 1] = \"NoBrowserSupport\", t[t.NoAudioConsent = 2] = \"NoAudioConsent\", t[t.__UnrecoverableErrors = 3] = \"__UnrecoverableErrors\", t[t.Disconnected = 4] = \"Disconnected\", t[t.Disconnecting = 5] = \"Disconnecting\", t[t.Connecting = 6] = \"Connecting\", t[t.Preinitialized = 7] = \"Preinitialized\", t[t.Initializing = 8] = \"Initializing\", t[t.Connected = 9] = \"Connected\", t[t.Stopping = 10] = \"Stopping\", t[t.Starting = 11] = \"Starting\", t[t.Recording = 12] = \"Recording\";\n  }(Q || (Q = {})), function (t) {\n    t.SpeechlyFirstConnect = \"SpeechlyFirstConnect\";\n  }(X || (X = {})), function (t) {\n    t.speechlypoweron = \"speechlypoweron\", t.holdstart = \"holdstart\", t.holdend = \"holdend\", t.speechstate = \"speechstate\", t.speechsegment = \"speechsegment\", t.speechhandled = \"speechhandled\", t.showhint = \"showhint\", t.transcriptdrawerhint = \"hint\", t.speechlyintroready = \"speechlyintroready\", t.speechlyintroclosed = \"speechlyintroclosed\";\n  }(Y || (Y = {})), function (t) {\n    t.Mic = \"mic\", t.MicActive = \"micactive\", t.Error = \"error\", t.Denied = \"denied\";\n  }(Z || (Z = {})), function (t) {\n    t.Hold = \"hold\", t.Click = \"click\", t.Noninteractive = \"noninteractive\";\n  }(tt || (tt = {})), function (t) {\n    t.None = \"none\", t.Connecting = \"connecting\", t.Busy = \"busy\";\n  }(et || (et = {})), function (t) {\n    t.None = \"none\", t.Whirl = \"whirl\";\n  }(nt || (nt = {}));\n  const ot = {\n    [Q.Disconnected]: {\n      icon: \"mic\",\n      behaviour: \"click\",\n      effect: \"none\",\n      triggerFx: \"whirl\"\n    },\n    [Q.Disconnecting]: {\n      icon: \"mic\",\n      behaviour: \"noninteractive\",\n      effect: \"connecting\"\n    },\n    [Q.Connecting]: {\n      icon: \"mic\",\n      behaviour: \"noninteractive\",\n      effect: \"connecting\"\n    },\n    [Q.Preinitialized]: {\n      icon: \"mic\",\n      behaviour: \"hold\",\n      effect: \"none\",\n      triggerFx: \"whirl\"\n    },\n    [Q.Initializing]: {\n      icon: \"mic\",\n      behaviour: \"noninteractive\",\n      effect: \"connecting\"\n    },\n    [Q.Connected]: {\n      icon: \"mic\",\n      behaviour: \"hold\",\n      effect: \"none\",\n      triggerFx: \"whirl\"\n    },\n    [Q.Starting]: {\n      icon: \"mic\",\n      behaviour: \"hold\",\n      effect: \"connecting\"\n    },\n    [Q.Recording]: {\n      icon: \"micactive\",\n      behaviour: \"hold\",\n      effect: \"none\"\n    },\n    [Q.Stopping]: {\n      icon: \"mic\",\n      behaviour: \"noninteractive\",\n      effect: \"busy\"\n    },\n    [Q.Failed]: {\n      icon: \"error\",\n      behaviour: \"click\",\n      effect: \"none\"\n    },\n    [Q.NoBrowserSupport]: {\n      icon: \"error\",\n      behaviour: \"click\",\n      effect: \"none\"\n    },\n    [Q.NoAudioConsent]: {\n      icon: \"denied\",\n      behaviour: \"click\",\n      effect: \"none\"\n    }\n  };\n\n  function it(t) {\n    l(t, \"svelte-s2u2hd\", \".Icon.svelte-s2u2hd{position:absolute;width:var(--icon-size);height:var(--icon-size);top:50%;left:50%;transform:translate(-50%, -50%);pointer-events:none;transition:0.25s;opacity:var(--icon-opacity)}\");\n  }\n\n  function rt(t) {\n    let e, n, o, i, r, s, c, l, f, g, $, v, x;\n    return {\n      c() {\n        e = h(\"svg\"), n = h(\"linearGradient\"), o = h(\"animate\"), i = h(\"animate\"), r = h(\"stop\"), s = h(\"stop\"), c = h(\"stop\"), l = h(\"stop\"), f = h(\"stop\"), g = p(\">\\n  \"), $ = h(\"g\"), v = h(\"path\"), x = h(\"rect\"), m(o, \"attributeName\", \"y1\"), m(o, \"values\", \"-200%; 0%;\"), m(o, \"dur\", \"2s\"), m(o, \"repeatCount\", \"indefinite\"), m(i, \"attributeName\", \"y2\"), m(i, \"values\", \"200%; 400%;\"), m(i, \"dur\", \"2s\"), m(i, \"repeatCount\", \"indefinite\"), m(r, \"offset\", \"0%\"), m(r, \"stop-color\", \"var(--gradient-stop1)\"), m(s, \"offset\", \"25%\"), m(s, \"stop-color\", \"var(--gradient-stop2)\"), m(c, \"offset\", \"50%\"), m(c, \"stop-color\", \"var(--gradient-stop1)\"), m(l, \"offset\", \"75%\"), m(l, \"stop-color\", \"var(--gradient-stop2)\"), m(f, \"offset\", \"100%\"), m(f, \"stop-color\", \"var(--gradient-stop1)\"), m(n, \"id\", \"gradient\"), m(n, \"x1\", \"50%\"), m(n, \"y1\", \"-200%\"), m(n, \"x2\", \"50%\"), m(n, \"y2\", \"200%\"), m(v, \"d\", \"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\"), m(x, \"x\", \"20\"), m(x, \"y\", \"1\"), m(x, \"width\", \"16\"), m(x, \"height\", \"37\"), m(x, \"rx\", \"8\"), m($, \"fill\", \"url(#gradient)\"), m($, \"fill-rule\", \"evenodd\"), m(e, \"class\", \"Icon svelte-s2u2hd\"), m(e, \"viewBox\", \"0 0 56 56\"), m(e, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      },\n\n      m(t, u) {\n        d(t, e, u), a(e, n), a(n, o), a(n, i), a(n, r), a(n, s), a(n, c), a(n, l), a(n, f), a(e, g), a(e, $), a($, v), a($, x);\n      },\n\n      d(t) {\n        t && u(e);\n      }\n\n    };\n  }\n\n  function st(t) {\n    let e, n, o, i;\n    return {\n      c() {\n        e = h(\"svg\"), n = h(\"g\"), o = h(\"path\"), i = h(\"rect\"), m(o, \"d\", \"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\"), m(i, \"x\", \"20\"), m(i, \"y\", \"1\"), m(i, \"width\", \"16\"), m(i, \"height\", \"37\"), m(i, \"rx\", \"8\"), m(n, \"fill\", \"var(--icon-color)\"), m(n, \"fill-rule\", \"evenodd\"), m(e, \"class\", \"Icon svelte-s2u2hd\"), m(e, \"viewBox\", \"0 0 56 56\"), m(e, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      },\n\n      m(t, r) {\n        d(t, e, r), a(e, n), a(n, o), a(n, i);\n      },\n\n      d(t) {\n        t && u(e);\n      }\n\n    };\n  }\n\n  function ct(t) {\n    let e, n, o, i;\n    return {\n      c() {\n        e = h(\"svg\"), n = h(\"g\"), o = h(\"path\"), i = h(\"path\"), m(o, \"d\", \"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\"), m(o, \"fill-rule\", \"nonzero\"), m(i, \"d\", \"M37 13.081V31a8 8 0 11-16 0v-1.919l16-16zM26 1a8 8 0 018 8v1.319L18 26.318V9a8 8 0 018-8zM37.969 7.932l3.74-7.35 3.018 2.625zM39.654 10.608l7.531-3.359.695 3.94z\"), m(n, \"fill\", \"var(--icon-color)\"), m(n, \"fill-rule\", \"evenodd\"), m(e, \"class\", \"Icon svelte-s2u2hd\"), m(e, \"viewBox\", \"0 0 56 56\"), m(e, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      },\n\n      m(t, r) {\n        d(t, e, r), a(e, n), a(n, o), a(n, i);\n      },\n\n      d(t) {\n        t && u(e);\n      }\n\n    };\n  }\n\n  function at(t) {\n    let e, n, o, i;\n    return {\n      c() {\n        e = h(\"svg\"), n = h(\"g\"), o = h(\"path\"), i = h(\"path\"), m(o, \"d\", \"M36 14.828V30a8 8 0 01-15.961.79l15.96-15.962zM28 1a8 8 0 018 8v.172L20 25.173V9a8 8 0 018-8z\"), m(i, \"d\", \"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\"), m(n, \"fill\", \"var(--icon-color)\"), m(n, \"fill-rule\", \"nonzero\"), m(e, \"class\", \"Icon svelte-s2u2hd\"), m(e, \"viewBox\", \"0 0 56 56\"), m(e, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      },\n\n      m(t, r) {\n        d(t, e, r), a(e, n), a(n, o), a(n, i);\n      },\n\n      d(t) {\n        t && u(e);\n      }\n\n    };\n  }\n\n  function lt(e) {\n    let n,\n        o,\n        i,\n        r,\n        s = e[0] === Z.MicActive && rt(),\n        c = e[0] === Z.Mic && st(),\n        a = e[0] === Z.Error && ct(),\n        l = e[0] === Z.Denied && at();\n    return {\n      c() {\n        s && s.c(), n = g(), c && c.c(), o = g(), a && a.c(), i = g(), l && l.c(), r = p(\"\");\n      },\n\n      m(t, e) {\n        s && s.m(t, e), d(t, n, e), c && c.m(t, e), d(t, o, e), a && a.m(t, e), d(t, i, e), l && l.m(t, e), d(t, r, e);\n      },\n\n      p(t, _ref2) {\n        let [e] = _ref2;\n        t[0] === Z.MicActive ? s || (s = rt(), s.c(), s.m(n.parentNode, n)) : s && (s.d(1), s = null), t[0] === Z.Mic ? c || (c = st(), c.c(), c.m(o.parentNode, o)) : c && (c.d(1), c = null), t[0] === Z.Error ? a || (a = ct(), a.c(), a.m(i.parentNode, i)) : a && (a.d(1), a = null), t[0] === Z.Denied ? l || (l = at(), l.c(), l.m(r.parentNode, r)) : l && (l.d(1), l = null);\n      },\n\n      i: t,\n      o: t,\n\n      d(t) {\n        s && s.d(t), t && u(n), c && c.d(t), t && u(o), a && a.d(t), t && u(i), l && l.d(t), t && u(r);\n      }\n\n    };\n  }\n\n  function dt(t, e, n) {\n    let {\n      icon: o = Z.Mic\n    } = e;\n    return t.$$set = t => {\n      \"icon\" in t && n(0, o = t.icon);\n    }, [o];\n  }\n\n  class ut extends U {\n    constructor(t) {\n      super(), j(this, t, dt, lt, r, {\n        icon: 0\n      }, it);\n    }\n\n  }\n\n  function ft(t) {\n    l(t, \"svelte-1fpkb0k\", \".Fx.svelte-1fpkb0k{position:absolute;width:var(--fx-size);height:var(--fx-size);top:50%;left:50%;transform-origin:50% 50%;transform:translate(-50%, -50%) rotate(var(--fx-rotation));pointer-events:none;opacity:var(--fx-opacity)}\");\n  }\n\n  function ht(e) {\n    let n, o, i, r, s, c, l, f;\n    return {\n      c() {\n        n = h(\"svg\"), o = h(\"defs\"), i = h(\"linearGradient\"), r = h(\"stop\"), s = h(\"stop\"), c = h(\"filter\"), l = h(\"feGaussianBlur\"), f = h(\"circle\"), m(r, \"stop-color\", \"var(--fx-gradient-stop1)\"), m(r, \"offset\", \"0%\"), m(s, \"stop-color\", \"var(--fx-gradient-stop2)\"), m(s, \"offset\", \"100%\"), m(i, \"x1\", \"50%\"), m(i, \"y1\", \"10%\"), m(i, \"x2\", \"50%\"), m(i, \"y2\", \"100%\"), m(i, \"id\", \"a\"), m(l, \"stdDeviation\", \"18\"), m(l, \"in\", \"SourceGraphic\"), m(c, \"x\", \"-35%\"), m(c, \"y\", \"-35%\"), m(c, \"width\", \"170%\"), m(c, \"height\", \"170%\"), m(c, \"filterUnits\", \"objectBoundingBox\"), m(c, \"id\", \"b\"), m(f, \"filter\", \"url(#b)\"), m(f, \"cx\", \"124\"), m(f, \"cy\", \"124\"), m(f, \"r\", \"79\"), m(f, \"fill\", \"url(#a)\"), m(f, \"fillrule\", \"evenodd\"), m(n, \"class\", \"Fx svelte-1fpkb0k\"), m(n, \"viewBox\", \"0 0 246 246\"), m(n, \"xmlns\", \"http://www.w3.org/2000/svg\");\n      },\n\n      m(t, e) {\n        d(t, n, e), a(n, o), a(o, i), a(i, r), a(i, s), a(o, c), a(c, l), a(n, f);\n      },\n\n      p: t,\n      i: t,\n      o: t,\n\n      d(t) {\n        t && u(n);\n      }\n\n    };\n  }\n\n  class pt extends U {\n    constructor(t) {\n      super(), j(this, t, null, ht, r, {}, ft);\n    }\n\n  }\n\n  const {\n    window: gt\n  } = P;\n\n  function $t(t) {\n    let e;\n    return {\n      c() {\n        e = f(\"link\"), m(e, \"href\", t[9]), m(e, \"rel\", \"stylesheet\");\n      },\n\n      m(t, n) {\n        d(t, e, n);\n      },\n\n      p(t, n) {\n        512 & n[0] && m(e, \"href\", t[9]);\n      },\n\n      d(t) {\n        t && u(e);\n      }\n\n    };\n  }\n\n  function mt(e) {\n    let n,\n        i,\n        r,\n        s,\n        c,\n        l,\n        h,\n        p,\n        w,\n        b,\n        y,\n        k,\n        z = void 0 !== e[9] && $t(e);\n    return r = new pt({}), c = new K({\n      props: {\n        frameRadius: e[16]\n      }\n    }), h = new ut({\n      props: {\n        icon: e[15].icon\n      }\n    }), {\n      c() {\n        z && z.c(), n = g(), i = f(\"main\"), T(r.$$.fragment), s = g(), T(c.$$.fragment), l = g(), T(h.$$.fragment), p = g(), w = f(\"slot\"), this.c = t, m(i, \"class\", \"HoldableButton\"), v(i, \"width\", e[0]), v(i, \"height\", e[0]), v(i, \"--gradient-stop1\", e[5]), v(i, \"--gradient-stop2\", e[6]), v(i, \"--fx-gradient-stop1\", e[7] || e[5]), v(i, \"--fx-gradient-stop2\", e[8] || e[6]), v(i, \"--fx-rotation\", e[11][1] + \"deg\"), v(i, \"--fx-opacity\", e[14][1]), v(i, \"--fx-size\", e[2]), v(i, \"--icon-opacity\", e[13][1]), v(i, \"--icon-size\", e[1]), v(i, \"--icon-color\", e[4]), v(i, \"--frame-stroke-width\", e[17]), v(i, \"--frame-background\", e[3]), v(i, \"transform\", \"scale(\" + e[12][1] + \")\"), x(i, \"pressed\", e[10]);\n      },\n\n      m(t, o) {\n        z && z.m(t, o), d(t, n, o), d(t, i, o), V(r, i, null), a(i, s), V(c, i, null), a(i, l), V(h, i, null), a(i, p), a(i, w), b = !0, y || (k = [$(gt, \"mouseup\", e[19]), $(gt, \"keydown\", e[20]), $(gt, \"keyup\", e[21]), $(i, \"mousedown\", e[18]), $(i, \"touchstart\", e[18]), $(i, \"dragstart\", e[18]), $(i, \"mouseup\", e[19]), $(i, \"touchend\", e[19], {\n          passive: !0\n        }), $(i, \"dragend\", e[19])], y = !0);\n      },\n\n      p(t, e) {\n        void 0 !== t[9] ? z ? z.p(t, e) : (z = $t(t), z.c(), z.m(n.parentNode, n)) : z && (z.d(1), z = null);\n        const o = {};\n        65536 & e[0] && (o.frameRadius = t[16]), c.$set(o);\n        const r = {};\n        32768 & e[0] && (r.icon = t[15].icon), h.$set(r), (!b || 1 & e[0]) && v(i, \"width\", t[0]), (!b || 1 & e[0]) && v(i, \"height\", t[0]), (!b || 32 & e[0]) && v(i, \"--gradient-stop1\", t[5]), (!b || 64 & e[0]) && v(i, \"--gradient-stop2\", t[6]), (!b || 160 & e[0]) && v(i, \"--fx-gradient-stop1\", t[7] || t[5]), (!b || 320 & e[0]) && v(i, \"--fx-gradient-stop2\", t[8] || t[6]), (!b || 2048 & e[0]) && v(i, \"--fx-rotation\", t[11][1] + \"deg\"), (!b || 16384 & e[0]) && v(i, \"--fx-opacity\", t[14][1]), (!b || 4 & e[0]) && v(i, \"--fx-size\", t[2]), (!b || 8192 & e[0]) && v(i, \"--icon-opacity\", t[13][1]), (!b || 2 & e[0]) && v(i, \"--icon-size\", t[1]), (!b || 16 & e[0]) && v(i, \"--icon-color\", t[4]), (!b || 131072 & e[0]) && v(i, \"--frame-stroke-width\", t[17]), (!b || 8 & e[0]) && v(i, \"--frame-background\", t[3]), (!b || 4096 & e[0]) && v(i, \"transform\", \"scale(\" + t[12][1] + \")\"), 1024 & e[0] && x(i, \"pressed\", t[10]);\n      },\n\n      i(t) {\n        b || (R(r.$$.fragment, t), R(c.$$.fragment, t), R(h.$$.fragment, t), b = !0);\n      },\n\n      o(t) {\n        I(r.$$.fragment, t), I(c.$$.fragment, t), I(h.$$.fragment, t), b = !1;\n      },\n\n      d(t) {\n        z && z.d(t), t && u(n), t && u(i), G(r), G(c), G(h), y = !1, o(k);\n      }\n\n    };\n  }\n\n  function vt(t, e, n) {\n    let o,\n        i,\n        r,\n        s,\n        {\n      icon: c = Q.Disconnected\n    } = e,\n        {\n      capturekey: a = \" \"\n    } = e,\n        {\n      hide: l\n    } = e,\n        {\n      size: d = \"80px\"\n    } = e,\n        {\n      holdscale: u = \"1.35\"\n    } = e,\n        {\n      borderscale: f = \"0.075\"\n    } = e,\n        {\n      iconsize: h = \"60%\"\n    } = e,\n        {\n      fxsize: p = \"250%\"\n    } = e,\n        {\n      backgroundcolor: g = \"#ffffff\"\n    } = e,\n        {\n      iconcolor: $ = \"#000000\"\n    } = e,\n        {\n      gradientstop1: m = \"#15e8b5\"\n    } = e,\n        {\n      gradientstop2: v = \"#4fa1f9\"\n    } = e,\n        {\n      fxgradientstop1: x\n    } = e,\n        {\n      fxgradientstop2: w\n    } = e,\n        {\n      customcssurl: b\n    } = e;\n    let y = !1,\n        z = 0,\n        E = [0, 0],\n        M = [0, 0],\n        _ = [1, 1],\n        C = [0, 0],\n        N = ot[c],\n        D = null,\n        B = 0,\n        F = 0;\n\n    const S = k(),\n          L = (t, e) => {\n      S.dispatchEvent(new CustomEvent(t, {\n        detail: e,\n        composed: !0\n      }));\n    };\n\n    var A;\n    A = () => {\n      n(12, M = [1, 0]);\n      let t = null;\n\n      const e = () => {\n        B = F, F = new Date().getTime();\n        const i = F - (B || F);\n        N.effect === et.Connecting && n(13, _[0] = .25 * Math.cos(F / 2500 * Math.PI * 2) + .25, _), N.effect === et.Busy && n(13, _[0] = .25 * Math.cos(F / 1e3 * Math.PI * 2) + .25, _), n(12, M = [M[0], P(M[1], o ? M[0] : 0, .2, i)]), n(13, _ = [_[0], P(_[1], _[0], .08, i)]), n(14, C = [C[0], P(C[1], C[0], .08, i)]), n(11, E = [E[0] + 2.5, P(E[1], E[0], .05, i)]), t = requestAnimationFrame(e);\n      };\n\n      return e(), () => cancelAnimationFrame(t);\n    }, k().$$.on_mount.push(A);\n\n    const R = t => {\n      t.preventDefault(), t.stopPropagation(), o && !y && (n(10, y = !0), z = Date.now(), T(), N.triggerFx === nt.Whirl && n(11, E[0] += 720, E), N.behaviour === tt.Click && null === D && (D = window.setTimeout(() => {\n        n(14, C[0] = 0, C), D = null;\n      }, 500)), S.onholdstart && S.onholdstart(), L(Y.holdstart));\n    },\n          I = () => {\n      if (y) {\n        n(10, y = !1);\n        const t = {\n          timeMs: Date.now() - z\n        };\n        T(), null !== D && window.clearTimeout(D), S.onholdend && S.onholdend(t), L(\"holdend\", t);\n      }\n    },\n          P = (t, e, n, o) => t * (1 - (n = Math.pow(n, 1e3 / 60 / o))) + e * n,\n          T = function () {\n      let t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;\n      void 0 !== navigator.vibrate && navigator.vibrate(t);\n    };\n\n    return t.$$set = t => {\n      \"icon\" in t && n(22, c = t.icon), \"capturekey\" in t && n(23, a = t.capturekey), \"hide\" in t && n(24, l = t.hide), \"size\" in t && n(0, d = t.size), \"holdscale\" in t && n(25, u = t.holdscale), \"borderscale\" in t && n(26, f = t.borderscale), \"iconsize\" in t && n(1, h = t.iconsize), \"fxsize\" in t && n(2, p = t.fxsize), \"backgroundcolor\" in t && n(3, g = t.backgroundcolor), \"iconcolor\" in t && n(4, $ = t.iconcolor), \"gradientstop1\" in t && n(5, m = t.gradientstop1), \"gradientstop2\" in t && n(6, v = t.gradientstop2), \"fxgradientstop1\" in t && n(7, x = t.fxgradientstop1), \"fxgradientstop2\" in t && n(8, w = t.fxgradientstop2), \"customcssurl\" in t && n(9, b = t.customcssurl);\n    }, t.$$.update = () => {\n      16777216 & t.$$.dirty[0] && (o = void 0 === l || \"false\" === l), 67108864 & t.$$.dirty[0] && n(17, i = \"\" + 46 * f), 67108864 & t.$$.dirty[0] && n(16, r = 46 - 23 * f), 33554432 & t.$$.dirty[0] && (s = u), 4195328 & t.$$.dirty[0] && ((t, e) => {\n        switch (n(15, N = ot[e]), n(12, M[0] = t ? s : 1, M), n(14, C[0] = t || e == Q.Recording ? 1 : 0, C), N.icon) {\n          case Z.MicActive:\n          case Z.Mic:\n          case Z.Denied:\n          case Z.Error:\n            n(13, _[0] = 1, _);\n        }\n      })(y, c);\n    }, [d, h, p, g, $, m, v, x, w, b, y, E, M, _, C, N, r, i, R, I, t => {\n      a && t.key === a && (document.hasFocus() && document.activeElement !== document.body && document.activeElement !== document.documentElement && document.activeElement || null || (t.repeat ? (t.preventDefault(), t.stopPropagation()) : R(t)));\n    }, t => {\n      t.key === a && I();\n    }, c, a, l, u, f, () => y];\n  }\n\n  class xt extends O {\n    constructor(t) {\n      super(), this.shadowRoot.innerHTML = \"<style>main{text-align:left;position:relative;pointer-events:auto;cursor:pointer;border-radius:50%;-webkit-tap-highlight-color:transparent;-webkit-touch-callout:none !important;-webkit-user-select:none !important}</style>\", j(this, {\n        target: this.shadowRoot,\n        props: w(this.attributes),\n        customElement: !0\n      }, vt, mt, s, {\n        icon: 22,\n        capturekey: 23,\n        hide: 24,\n        size: 0,\n        holdscale: 25,\n        borderscale: 26,\n        iconsize: 1,\n        fxsize: 2,\n        backgroundcolor: 3,\n        iconcolor: 4,\n        gradientstop1: 5,\n        gradientstop2: 6,\n        fxgradientstop1: 7,\n        fxgradientstop2: 8,\n        customcssurl: 9,\n        isbuttonpressed: 27\n      }, null, [-1, -1]), t && (t.target && d(t.target, this, t.anchor), t.props && (this.$set(t.props), S()));\n    }\n\n    static get observedAttributes() {\n      return [\"icon\", \"capturekey\", \"hide\", \"size\", \"holdscale\", \"borderscale\", \"iconsize\", \"fxsize\", \"backgroundcolor\", \"iconcolor\", \"gradientstop1\", \"gradientstop2\", \"fxgradientstop1\", \"fxgradientstop2\", \"customcssurl\", \"isbuttonpressed\"];\n    }\n\n    get icon() {\n      return this.$$.ctx[22];\n    }\n\n    set icon(t) {\n      this.$$set({\n        icon: t\n      }), S();\n    }\n\n    get capturekey() {\n      return this.$$.ctx[23];\n    }\n\n    set capturekey(t) {\n      this.$$set({\n        capturekey: t\n      }), S();\n    }\n\n    get hide() {\n      return this.$$.ctx[24];\n    }\n\n    set hide(t) {\n      this.$$set({\n        hide: t\n      }), S();\n    }\n\n    get size() {\n      return this.$$.ctx[0];\n    }\n\n    set size(t) {\n      this.$$set({\n        size: t\n      }), S();\n    }\n\n    get holdscale() {\n      return this.$$.ctx[25];\n    }\n\n    set holdscale(t) {\n      this.$$set({\n        holdscale: t\n      }), S();\n    }\n\n    get borderscale() {\n      return this.$$.ctx[26];\n    }\n\n    set borderscale(t) {\n      this.$$set({\n        borderscale: t\n      }), S();\n    }\n\n    get iconsize() {\n      return this.$$.ctx[1];\n    }\n\n    set iconsize(t) {\n      this.$$set({\n        iconsize: t\n      }), S();\n    }\n\n    get fxsize() {\n      return this.$$.ctx[2];\n    }\n\n    set fxsize(t) {\n      this.$$set({\n        fxsize: t\n      }), S();\n    }\n\n    get backgroundcolor() {\n      return this.$$.ctx[3];\n    }\n\n    set backgroundcolor(t) {\n      this.$$set({\n        backgroundcolor: t\n      }), S();\n    }\n\n    get iconcolor() {\n      return this.$$.ctx[4];\n    }\n\n    set iconcolor(t) {\n      this.$$set({\n        iconcolor: t\n      }), S();\n    }\n\n    get gradientstop1() {\n      return this.$$.ctx[5];\n    }\n\n    set gradientstop1(t) {\n      this.$$set({\n        gradientstop1: t\n      }), S();\n    }\n\n    get gradientstop2() {\n      return this.$$.ctx[6];\n    }\n\n    set gradientstop2(t) {\n      this.$$set({\n        gradientstop2: t\n      }), S();\n    }\n\n    get fxgradientstop1() {\n      return this.$$.ctx[7];\n    }\n\n    set fxgradientstop1(t) {\n      this.$$set({\n        fxgradientstop1: t\n      }), S();\n    }\n\n    get fxgradientstop2() {\n      return this.$$.ctx[8];\n    }\n\n    set fxgradientstop2(t) {\n      this.$$set({\n        fxgradientstop2: t\n      }), S();\n    }\n\n    get customcssurl() {\n      return this.$$.ctx[9];\n    }\n\n    set customcssurl(t) {\n      this.$$set({\n        customcssurl: t\n      }), S();\n    }\n\n    get isbuttonpressed() {\n      return this.$$.ctx[27];\n    }\n\n  }\n\n  customElements.get(\"holdable-button\") ? console.warn(\"Skipping re-defining customElement holdable-button\") : customElements.define(\"holdable-button\", xt);\n});","map":{"version":3,"mappings":"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","names":["noop","run","fn","blank_object","Object","create","run_all","fns","forEach","is_function","thing","safe_not_equal","a","b","not_equal","is_empty","obj","keys","length","append","target","node","appendChild","append_styles","style_sheet_id","styles","append_styles_to","document","root","getRootNode","ownerDocument","host","get_root_for_style","getElementById","style","element","id","textContent","head","append_stylesheet","insert","anchor","insertBefore","detach","parentNode","removeChild","name","createElement","svg_element","createElementNS","text","data","createTextNode","space","listen","event","handler","options","addEventListener","removeEventListener","attr","attribute","value","removeAttribute","getAttribute","setAttribute","set_style","key","important","setProperty","toggle_class","toggle","classList","attribute_to_object","attributes","result","current_component","set_current_component","component","get_current_component","Error","dirty_components","binding_callbacks","render_callbacks","flush_callbacks","resolved_promise","Promise","resolve","update_scheduled","add_render_callback","push","flushing","seen_callbacks","Set","flush","i","update","$$","pop","callback","has","add","clear","fragment","before_update","dirty","p","ctx","after_update","outroing","transition_in","block","local","delete","transition_out","o","outros","c","d","globals","window","globalThis","global","create_component","mount_component","customElement","on_mount","on_destroy","m","new_on_destroy","map","filter","destroy_component","detaching","make_dirty","then","fill","init","instance","create_fragment","props","parent_component","bound","on_disconnect","context","Map","callbacks","skip_bound","ready","ret","rest","hydrate","nodes","Array","from","childNodes","children","l","intro","SvelteElement","HTMLElement","constructor","super","this","attachShadow","mode","connectedCallback","slotted","attributeChangedCallback","_oldValue","newValue","disconnectedCallback","$destroy","$on","type","index","indexOf","splice","$set","$$props","$$set","SvelteComponent","n","frameRadius","e","ClientState","LocalStorageKeys","MessageType","Icon","Behaviour","Effect","TriggerFx","clientStateToAppearance","Disconnected","icon","behaviour","effect","triggerFx","Disconnecting","Connecting","Preinitialized","Initializing","Connected","Starting","Recording","Stopping","Failed","NoBrowserSupport","NoAudioConsent","$","v","x","MicActive","Mic","Denied","s","undefined","capturekey","hide","size","holdscale","borderscale","iconsize","fxsize","backgroundcolor","iconcolor","gradientstop1","gradientstop2","fxgradientstop1","fxgradientstop2","customcssurl","tangentHeld","holdStartTimestamp","rotation","scale","iconOpacity","fxOpacity","effectiveAppearance","timeout","prevFrameMillis","frameMillis","thisComponent","dispatchUnbounded","detail","composed","requestId","tick","getTime","tickMs","_","Busy","animateValue","cancelAnimationFrame","tangentStart","visible","vibrate","Whirl","E","setTimeout","C","holdstart","tangentEnd","eventPayload","timeMs","pull","navigator","durationMs","frameStrokeWidth","buttonHeldScale","buttonHeld","clientState","M","customElements","get","console","warn","define","el"],"sources":["../../../common/temp/node_modules/.pnpm/svelte@3.44.2/node_modules/svelte/internal/index.mjs","../src/components/MicFrame.svelte","../../node_modules/@speechly/browser-client/src/speechly/types.ts","../../src/constants.ts","../src/components/MicIcon.svelte","../src/components/MicFx.svelte","../src/holdable-button.svelte","../../src/holdable-button.ts"],"sourcesContent":["function noop() { }\nconst identity = x => x;\nfunction assign(tar, src) {\n    // @ts-ignore\n    for (const k in src)\n        tar[k] = src[k];\n    return tar;\n}\nfunction is_promise(value) {\n    return value && typeof value === 'object' && typeof value.then === 'function';\n}\nfunction add_location(element, file, line, column, char) {\n    element.__svelte_meta = {\n        loc: { file, line, column, char }\n    };\n}\nfunction run(fn) {\n    return fn();\n}\nfunction blank_object() {\n    return Object.create(null);\n}\nfunction run_all(fns) {\n    fns.forEach(run);\n}\nfunction is_function(thing) {\n    return typeof thing === 'function';\n}\nfunction safe_not_equal(a, b) {\n    return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');\n}\nlet src_url_equal_anchor;\nfunction src_url_equal(element_src, url) {\n    if (!src_url_equal_anchor) {\n        src_url_equal_anchor = document.createElement('a');\n    }\n    src_url_equal_anchor.href = url;\n    return element_src === src_url_equal_anchor.href;\n}\nfunction not_equal(a, b) {\n    return a != a ? b == b : a !== b;\n}\nfunction is_empty(obj) {\n    return Object.keys(obj).length === 0;\n}\nfunction validate_store(store, name) {\n    if (store != null && typeof store.subscribe !== 'function') {\n        throw new Error(`'${name}' is not a store with a 'subscribe' method`);\n    }\n}\nfunction subscribe(store, ...callbacks) {\n    if (store == null) {\n        return noop;\n    }\n    const unsub = store.subscribe(...callbacks);\n    return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;\n}\nfunction get_store_value(store) {\n    let value;\n    subscribe(store, _ => value = _)();\n    return value;\n}\nfunction component_subscribe(component, store, callback) {\n    component.$$.on_destroy.push(subscribe(store, callback));\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n    if (definition) {\n        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n        return definition[0](slot_ctx);\n    }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n    return definition[1] && fn\n        ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))\n        : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n    if (definition[2] && fn) {\n        const lets = definition[2](fn(dirty));\n        if ($$scope.dirty === undefined) {\n            return lets;\n        }\n        if (typeof lets === 'object') {\n            const merged = [];\n            const len = Math.max($$scope.dirty.length, lets.length);\n            for (let i = 0; i < len; i += 1) {\n                merged[i] = $$scope.dirty[i] | lets[i];\n            }\n            return merged;\n        }\n        return $$scope.dirty | lets;\n    }\n    return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n    if (slot_changes) {\n        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n        slot.p(slot_context, slot_changes);\n    }\n}\nfunction update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {\n    const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);\n    update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn);\n}\nfunction get_all_dirty_from_scope($$scope) {\n    if ($$scope.ctx.length > 32) {\n        const dirty = [];\n        const length = $$scope.ctx.length / 32;\n        for (let i = 0; i < length; i++) {\n            dirty[i] = -1;\n        }\n        return dirty;\n    }\n    return -1;\n}\nfunction exclude_internal_props(props) {\n    const result = {};\n    for (const k in props)\n        if (k[0] !== '$')\n            result[k] = props[k];\n    return result;\n}\nfunction compute_rest_props(props, keys) {\n    const rest = {};\n    keys = new Set(keys);\n    for (const k in props)\n        if (!keys.has(k) && k[0] !== '$')\n            rest[k] = props[k];\n    return rest;\n}\nfunction compute_slots(slots) {\n    const result = {};\n    for (const key in slots) {\n        result[key] = true;\n    }\n    return result;\n}\nfunction once(fn) {\n    let ran = false;\n    return function (...args) {\n        if (ran)\n            return;\n        ran = true;\n        fn.call(this, ...args);\n    };\n}\nfunction null_to_empty(value) {\n    return value == null ? '' : value;\n}\nfunction set_store_value(store, ret, value) {\n    store.set(value);\n    return ret;\n}\nconst has_prop = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);\nfunction action_destroyer(action_result) {\n    return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;\n}\n\nconst is_client = typeof window !== 'undefined';\nlet now = is_client\n    ? () => window.performance.now()\n    : () => Date.now();\nlet raf = is_client ? cb => requestAnimationFrame(cb) : noop;\n// used internally for testing\nfunction set_now(fn) {\n    now = fn;\n}\nfunction set_raf(fn) {\n    raf = fn;\n}\n\nconst tasks = new Set();\nfunction run_tasks(now) {\n    tasks.forEach(task => {\n        if (!task.c(now)) {\n            tasks.delete(task);\n            task.f();\n        }\n    });\n    if (tasks.size !== 0)\n        raf(run_tasks);\n}\n/**\n * For testing purposes only!\n */\nfunction clear_loops() {\n    tasks.clear();\n}\n/**\n * Creates a new task that runs on each raf frame\n * until it returns a falsy value or is aborted\n */\nfunction loop(callback) {\n    let task;\n    if (tasks.size === 0)\n        raf(run_tasks);\n    return {\n        promise: new Promise(fulfill => {\n            tasks.add(task = { c: callback, f: fulfill });\n        }),\n        abort() {\n            tasks.delete(task);\n        }\n    };\n}\n\n// Track which nodes are claimed during hydration. Unclaimed nodes can then be removed from the DOM\n// at the end of hydration without touching the remaining nodes.\nlet is_hydrating = false;\nfunction start_hydrating() {\n    is_hydrating = true;\n}\nfunction end_hydrating() {\n    is_hydrating = false;\n}\nfunction upper_bound(low, high, key, value) {\n    // Return first index of value larger than input value in the range [low, high)\n    while (low < high) {\n        const mid = low + ((high - low) >> 1);\n        if (key(mid) <= value) {\n            low = mid + 1;\n        }\n        else {\n            high = mid;\n        }\n    }\n    return low;\n}\nfunction init_hydrate(target) {\n    if (target.hydrate_init)\n        return;\n    target.hydrate_init = true;\n    // We know that all children have claim_order values since the unclaimed have been detached if target is not <head>\n    let children = target.childNodes;\n    // If target is <head>, there may be children without claim_order\n    if (target.nodeName === 'HEAD') {\n        const myChildren = [];\n        for (let i = 0; i < children.length; i++) {\n            const node = children[i];\n            if (node.claim_order !== undefined) {\n                myChildren.push(node);\n            }\n        }\n        children = myChildren;\n    }\n    /*\n    * Reorder claimed children optimally.\n    * We can reorder claimed children optimally by finding the longest subsequence of\n    * nodes that are already claimed in order and only moving the rest. The longest\n    * subsequence subsequence of nodes that are claimed in order can be found by\n    * computing the longest increasing subsequence of .claim_order values.\n    *\n    * This algorithm is optimal in generating the least amount of reorder operations\n    * possible.\n    *\n    * Proof:\n    * We know that, given a set of reordering operations, the nodes that do not move\n    * always form an increasing subsequence, since they do not move among each other\n    * meaning that they must be already ordered among each other. Thus, the maximal\n    * set of nodes that do not move form a longest increasing subsequence.\n    */\n    // Compute longest increasing subsequence\n    // m: subsequence length j => index k of smallest value that ends an increasing subsequence of length j\n    const m = new Int32Array(children.length + 1);\n    // Predecessor indices + 1\n    const p = new Int32Array(children.length);\n    m[0] = -1;\n    let longest = 0;\n    for (let i = 0; i < children.length; i++) {\n        const current = children[i].claim_order;\n        // Find the largest subsequence length such that it ends in a value less than our current value\n        // upper_bound returns first greater value, so we subtract one\n        // with fast path for when we are on the current longest subsequence\n        const seqLen = ((longest > 0 && children[m[longest]].claim_order <= current) ? longest + 1 : upper_bound(1, longest, idx => children[m[idx]].claim_order, current)) - 1;\n        p[i] = m[seqLen] + 1;\n        const newLen = seqLen + 1;\n        // We can guarantee that current is the smallest value. Otherwise, we would have generated a longer sequence.\n        m[newLen] = i;\n        longest = Math.max(newLen, longest);\n    }\n    // The longest increasing subsequence of nodes (initially reversed)\n    const lis = [];\n    // The rest of the nodes, nodes that will be moved\n    const toMove = [];\n    let last = children.length - 1;\n    for (let cur = m[longest] + 1; cur != 0; cur = p[cur - 1]) {\n        lis.push(children[cur - 1]);\n        for (; last >= cur; last--) {\n            toMove.push(children[last]);\n        }\n        last--;\n    }\n    for (; last >= 0; last--) {\n        toMove.push(children[last]);\n    }\n    lis.reverse();\n    // We sort the nodes being moved to guarantee that their insertion order matches the claim order\n    toMove.sort((a, b) => a.claim_order - b.claim_order);\n    // Finally, we move the nodes\n    for (let i = 0, j = 0; i < toMove.length; i++) {\n        while (j < lis.length && toMove[i].claim_order >= lis[j].claim_order) {\n            j++;\n        }\n        const anchor = j < lis.length ? lis[j] : null;\n        target.insertBefore(toMove[i], anchor);\n    }\n}\nfunction append(target, node) {\n    target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n    const append_styles_to = get_root_for_style(target);\n    if (!append_styles_to.getElementById(style_sheet_id)) {\n        const style = element('style');\n        style.id = style_sheet_id;\n        style.textContent = styles;\n        append_stylesheet(append_styles_to, style);\n    }\n}\nfunction get_root_for_style(node) {\n    if (!node)\n        return document;\n    const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n    if (root && root.host) {\n        return root;\n    }\n    return node.ownerDocument;\n}\nfunction append_empty_stylesheet(node) {\n    const style_element = element('style');\n    append_stylesheet(get_root_for_style(node), style_element);\n    return style_element;\n}\nfunction append_stylesheet(node, style) {\n    append(node.head || node, style);\n}\nfunction append_hydration(target, node) {\n    if (is_hydrating) {\n        init_hydrate(target);\n        if ((target.actual_end_child === undefined) || ((target.actual_end_child !== null) && (target.actual_end_child.parentElement !== target))) {\n            target.actual_end_child = target.firstChild;\n        }\n        // Skip nodes of undefined ordering\n        while ((target.actual_end_child !== null) && (target.actual_end_child.claim_order === undefined)) {\n            target.actual_end_child = target.actual_end_child.nextSibling;\n        }\n        if (node !== target.actual_end_child) {\n            // We only insert if the ordering of this node should be modified or the parent node is not target\n            if (node.claim_order !== undefined || node.parentNode !== target) {\n                target.insertBefore(node, target.actual_end_child);\n            }\n        }\n        else {\n            target.actual_end_child = node.nextSibling;\n        }\n    }\n    else if (node.parentNode !== target || node.nextSibling !== null) {\n        target.appendChild(node);\n    }\n}\nfunction insert(target, node, anchor) {\n    target.insertBefore(node, anchor || null);\n}\nfunction insert_hydration(target, node, anchor) {\n    if (is_hydrating && !anchor) {\n        append_hydration(target, node);\n    }\n    else if (node.parentNode !== target || node.nextSibling != anchor) {\n        target.insertBefore(node, anchor || null);\n    }\n}\nfunction detach(node) {\n    node.parentNode.removeChild(node);\n}\nfunction destroy_each(iterations, detaching) {\n    for (let i = 0; i < iterations.length; i += 1) {\n        if (iterations[i])\n            iterations[i].d(detaching);\n    }\n}\nfunction element(name) {\n    return document.createElement(name);\n}\nfunction element_is(name, is) {\n    return document.createElement(name, { is });\n}\nfunction object_without_properties(obj, exclude) {\n    const target = {};\n    for (const k in obj) {\n        if (has_prop(obj, k)\n            // @ts-ignore\n            && exclude.indexOf(k) === -1) {\n            // @ts-ignore\n            target[k] = obj[k];\n        }\n    }\n    return target;\n}\nfunction svg_element(name) {\n    return document.createElementNS('http://www.w3.org/2000/svg', name);\n}\nfunction text(data) {\n    return document.createTextNode(data);\n}\nfunction space() {\n    return text(' ');\n}\nfunction empty() {\n    return text('');\n}\nfunction listen(node, event, handler, options) {\n    node.addEventListener(event, handler, options);\n    return () => node.removeEventListener(event, handler, options);\n}\nfunction prevent_default(fn) {\n    return function (event) {\n        event.preventDefault();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction stop_propagation(fn) {\n    return function (event) {\n        event.stopPropagation();\n        // @ts-ignore\n        return fn.call(this, event);\n    };\n}\nfunction self(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.target === this)\n            fn.call(this, event);\n    };\n}\nfunction trusted(fn) {\n    return function (event) {\n        // @ts-ignore\n        if (event.isTrusted)\n            fn.call(this, event);\n    };\n}\nfunction attr(node, attribute, value) {\n    if (value == null)\n        node.removeAttribute(attribute);\n    else if (node.getAttribute(attribute) !== value)\n        node.setAttribute(attribute, value);\n}\nfunction set_attributes(node, attributes) {\n    // @ts-ignore\n    const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);\n    for (const key in attributes) {\n        if (attributes[key] == null) {\n            node.removeAttribute(key);\n        }\n        else if (key === 'style') {\n            node.style.cssText = attributes[key];\n        }\n        else if (key === '__value') {\n            node.value = node[key] = attributes[key];\n        }\n        else if (descriptors[key] && descriptors[key].set) {\n            node[key] = attributes[key];\n        }\n        else {\n            attr(node, key, attributes[key]);\n        }\n    }\n}\nfunction set_svg_attributes(node, attributes) {\n    for (const key in attributes) {\n        attr(node, key, attributes[key]);\n    }\n}\nfunction set_custom_element_data(node, prop, value) {\n    if (prop in node) {\n        node[prop] = typeof node[prop] === 'boolean' && value === '' ? true : value;\n    }\n    else {\n        attr(node, prop, value);\n    }\n}\nfunction xlink_attr(node, attribute, value) {\n    node.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\nfunction get_binding_group_value(group, __value, checked) {\n    const value = new Set();\n    for (let i = 0; i < group.length; i += 1) {\n        if (group[i].checked)\n            value.add(group[i].__value);\n    }\n    if (!checked) {\n        value.delete(__value);\n    }\n    return Array.from(value);\n}\nfunction to_number(value) {\n    return value === '' ? null : +value;\n}\nfunction time_ranges_to_array(ranges) {\n    const array = [];\n    for (let i = 0; i < ranges.length; i += 1) {\n        array.push({ start: ranges.start(i), end: ranges.end(i) });\n    }\n    return array;\n}\nfunction children(element) {\n    return Array.from(element.childNodes);\n}\nfunction init_claim_info(nodes) {\n    if (nodes.claim_info === undefined) {\n        nodes.claim_info = { last_index: 0, total_claimed: 0 };\n    }\n}\nfunction claim_node(nodes, predicate, processNode, createNode, dontUpdateLastIndex = false) {\n    // Try to find nodes in an order such that we lengthen the longest increasing subsequence\n    init_claim_info(nodes);\n    const resultNode = (() => {\n        // We first try to find an element after the previous one\n        for (let i = nodes.claim_info.last_index; i < nodes.length; i++) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                return node;\n            }\n        }\n        // Otherwise, we try to find one before\n        // We iterate in reverse so that we don't go too far back\n        for (let i = nodes.claim_info.last_index - 1; i >= 0; i--) {\n            const node = nodes[i];\n            if (predicate(node)) {\n                const replacement = processNode(node);\n                if (replacement === undefined) {\n                    nodes.splice(i, 1);\n                }\n                else {\n                    nodes[i] = replacement;\n                }\n                if (!dontUpdateLastIndex) {\n                    nodes.claim_info.last_index = i;\n                }\n                else if (replacement === undefined) {\n                    // Since we spliced before the last_index, we decrease it\n                    nodes.claim_info.last_index--;\n                }\n                return node;\n            }\n        }\n        // If we can't find any matching node, we create a new one\n        return createNode();\n    })();\n    resultNode.claim_order = nodes.claim_info.total_claimed;\n    nodes.claim_info.total_claimed += 1;\n    return resultNode;\n}\nfunction claim_element_base(nodes, name, attributes, create_element) {\n    return claim_node(nodes, (node) => node.nodeName === name, (node) => {\n        const remove = [];\n        for (let j = 0; j < node.attributes.length; j++) {\n            const attribute = node.attributes[j];\n            if (!attributes[attribute.name]) {\n                remove.push(attribute.name);\n            }\n        }\n        remove.forEach(v => node.removeAttribute(v));\n        return undefined;\n    }, () => create_element(name));\n}\nfunction claim_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, element);\n}\nfunction claim_svg_element(nodes, name, attributes) {\n    return claim_element_base(nodes, name, attributes, svg_element);\n}\nfunction claim_text(nodes, data) {\n    return claim_node(nodes, (node) => node.nodeType === 3, (node) => {\n        const dataStr = '' + data;\n        if (node.data.startsWith(dataStr)) {\n            if (node.data.length !== dataStr.length) {\n                return node.splitText(dataStr.length);\n            }\n        }\n        else {\n            node.data = dataStr;\n        }\n    }, () => text(data), true // Text nodes should not update last index since it is likely not worth it to eliminate an increasing subsequence of actual elements\n    );\n}\nfunction claim_space(nodes) {\n    return claim_text(nodes, ' ');\n}\nfunction find_comment(nodes, text, start) {\n    for (let i = start; i < nodes.length; i += 1) {\n        const node = nodes[i];\n        if (node.nodeType === 8 /* comment node */ && node.textContent.trim() === text) {\n            return i;\n        }\n    }\n    return nodes.length;\n}\nfunction claim_html_tag(nodes) {\n    // find html opening tag\n    const start_index = find_comment(nodes, 'HTML_TAG_START', 0);\n    const end_index = find_comment(nodes, 'HTML_TAG_END', start_index);\n    if (start_index === end_index) {\n        return new HtmlTagHydration();\n    }\n    init_claim_info(nodes);\n    const html_tag_nodes = nodes.splice(start_index, end_index + 1);\n    detach(html_tag_nodes[0]);\n    detach(html_tag_nodes[html_tag_nodes.length - 1]);\n    const claimed_nodes = html_tag_nodes.slice(1, html_tag_nodes.length - 1);\n    for (const n of claimed_nodes) {\n        n.claim_order = nodes.claim_info.total_claimed;\n        nodes.claim_info.total_claimed += 1;\n    }\n    return new HtmlTagHydration(claimed_nodes);\n}\nfunction set_data(text, data) {\n    data = '' + data;\n    if (text.wholeText !== data)\n        text.data = data;\n}\nfunction set_input_value(input, value) {\n    input.value = value == null ? '' : value;\n}\nfunction set_input_type(input, type) {\n    try {\n        input.type = type;\n    }\n    catch (e) {\n        // do nothing\n    }\n}\nfunction set_style(node, key, value, important) {\n    node.style.setProperty(key, value, important ? 'important' : '');\n}\nfunction select_option(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        if (option.__value === value) {\n            option.selected = true;\n            return;\n        }\n    }\n    select.selectedIndex = -1; // no option should be selected\n}\nfunction select_options(select, value) {\n    for (let i = 0; i < select.options.length; i += 1) {\n        const option = select.options[i];\n        option.selected = ~value.indexOf(option.__value);\n    }\n}\nfunction select_value(select) {\n    const selected_option = select.querySelector(':checked') || select.options[0];\n    return selected_option && selected_option.__value;\n}\nfunction select_multiple_value(select) {\n    return [].map.call(select.querySelectorAll(':checked'), option => option.__value);\n}\n// unfortunately this can't be a constant as that wouldn't be tree-shakeable\n// so we cache the result instead\nlet crossorigin;\nfunction is_crossorigin() {\n    if (crossorigin === undefined) {\n        crossorigin = false;\n        try {\n            if (typeof window !== 'undefined' && window.parent) {\n                void window.parent.document;\n            }\n        }\n        catch (error) {\n            crossorigin = true;\n        }\n    }\n    return crossorigin;\n}\nfunction add_resize_listener(node, fn) {\n    const computed_style = getComputedStyle(node);\n    if (computed_style.position === 'static') {\n        node.style.position = 'relative';\n    }\n    const iframe = element('iframe');\n    iframe.setAttribute('style', 'display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ' +\n        'overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: -1;');\n    iframe.setAttribute('aria-hidden', 'true');\n    iframe.tabIndex = -1;\n    const crossorigin = is_crossorigin();\n    let unsubscribe;\n    if (crossorigin) {\n        iframe.src = \"data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>\";\n        unsubscribe = listen(window, 'message', (event) => {\n            if (event.source === iframe.contentWindow)\n                fn();\n        });\n    }\n    else {\n        iframe.src = 'about:blank';\n        iframe.onload = () => {\n            unsubscribe = listen(iframe.contentWindow, 'resize', fn);\n        };\n    }\n    append(node, iframe);\n    return () => {\n        if (crossorigin) {\n            unsubscribe();\n        }\n        else if (unsubscribe && iframe.contentWindow) {\n            unsubscribe();\n        }\n        detach(iframe);\n    };\n}\nfunction toggle_class(element, name, toggle) {\n    element.classList[toggle ? 'add' : 'remove'](name);\n}\nfunction custom_event(type, detail, bubbles = false) {\n    const e = document.createEvent('CustomEvent');\n    e.initCustomEvent(type, bubbles, false, detail);\n    return e;\n}\nfunction query_selector_all(selector, parent = document.body) {\n    return Array.from(parent.querySelectorAll(selector));\n}\nclass HtmlTag {\n    constructor() {\n        this.e = this.n = null;\n    }\n    c(html) {\n        this.h(html);\n    }\n    m(html, target, anchor = null) {\n        if (!this.e) {\n            this.e = element(target.nodeName);\n            this.t = target;\n            this.c(html);\n        }\n        this.i(anchor);\n    }\n    h(html) {\n        this.e.innerHTML = html;\n        this.n = Array.from(this.e.childNodes);\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert(this.t, this.n[i], anchor);\n        }\n    }\n    p(html) {\n        this.d();\n        this.h(html);\n        this.i(this.a);\n    }\n    d() {\n        this.n.forEach(detach);\n    }\n}\nclass HtmlTagHydration extends HtmlTag {\n    constructor(claimed_nodes) {\n        super();\n        this.e = this.n = null;\n        this.l = claimed_nodes;\n    }\n    c(html) {\n        if (this.l) {\n            this.n = this.l;\n        }\n        else {\n            super.c(html);\n        }\n    }\n    i(anchor) {\n        for (let i = 0; i < this.n.length; i += 1) {\n            insert_hydration(this.t, this.n[i], anchor);\n        }\n    }\n}\nfunction attribute_to_object(attributes) {\n    const result = {};\n    for (const attribute of attributes) {\n        result[attribute.name] = attribute.value;\n    }\n    return result;\n}\nfunction get_custom_elements_slots(element) {\n    const result = {};\n    element.childNodes.forEach((node) => {\n        result[node.slot || 'default'] = true;\n    });\n    return result;\n}\n\nconst active_docs = new Set();\nlet active = 0;\n// https://github.com/darkskyapp/string-hash/blob/master/index.js\nfunction hash(str) {\n    let hash = 5381;\n    let i = str.length;\n    while (i--)\n        hash = ((hash << 5) - hash) ^ str.charCodeAt(i);\n    return hash >>> 0;\n}\nfunction create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {\n    const step = 16.666 / duration;\n    let keyframes = '{\\n';\n    for (let p = 0; p <= 1; p += step) {\n        const t = a + (b - a) * ease(p);\n        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\\n`;\n    }\n    const rule = keyframes + `100% {${fn(b, 1 - b)}}\\n}`;\n    const name = `__svelte_${hash(rule)}_${uid}`;\n    const doc = get_root_for_style(node);\n    active_docs.add(doc);\n    const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = append_empty_stylesheet(node).sheet);\n    const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});\n    if (!current_rules[name]) {\n        current_rules[name] = true;\n        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);\n    }\n    const animation = node.style.animation || '';\n    node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;\n    active += 1;\n    return name;\n}\nfunction delete_rule(node, name) {\n    const previous = (node.style.animation || '').split(', ');\n    const next = previous.filter(name\n        ? anim => anim.indexOf(name) < 0 // remove specific animation\n        : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations\n    );\n    const deleted = previous.length - next.length;\n    if (deleted) {\n        node.style.animation = next.join(', ');\n        active -= deleted;\n        if (!active)\n            clear_rules();\n    }\n}\nfunction clear_rules() {\n    raf(() => {\n        if (active)\n            return;\n        active_docs.forEach(doc => {\n            const stylesheet = doc.__svelte_stylesheet;\n            let i = stylesheet.cssRules.length;\n            while (i--)\n                stylesheet.deleteRule(i);\n            doc.__svelte_rules = {};\n        });\n        active_docs.clear();\n    });\n}\n\nfunction create_animation(node, from, fn, params) {\n    if (!from)\n        return noop;\n    const to = node.getBoundingClientRect();\n    if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)\n        return noop;\n    const { delay = 0, duration = 300, easing = identity, \n    // @ts-ignore todo: should this be separated from destructuring? Or start/end added to public api and documentation?\n    start: start_time = now() + delay, \n    // @ts-ignore todo:\n    end = start_time + duration, tick = noop, css } = fn(node, { from, to }, params);\n    let running = true;\n    let started = false;\n    let name;\n    function start() {\n        if (css) {\n            name = create_rule(node, 0, 1, duration, delay, easing, css);\n        }\n        if (!delay) {\n            started = true;\n        }\n    }\n    function stop() {\n        if (css)\n            delete_rule(node, name);\n        running = false;\n    }\n    loop(now => {\n        if (!started && now >= start_time) {\n            started = true;\n        }\n        if (started && now >= end) {\n            tick(1, 0);\n            stop();\n        }\n        if (!running) {\n            return false;\n        }\n        if (started) {\n            const p = now - start_time;\n            const t = 0 + 1 * easing(p / duration);\n            tick(t, 1 - t);\n        }\n        return true;\n    });\n    start();\n    tick(0, 1);\n    return stop;\n}\nfunction fix_position(node) {\n    const style = getComputedStyle(node);\n    if (style.position !== 'absolute' && style.position !== 'fixed') {\n        const { width, height } = style;\n        const a = node.getBoundingClientRect();\n        node.style.position = 'absolute';\n        node.style.width = width;\n        node.style.height = height;\n        add_transform(node, a);\n    }\n}\nfunction add_transform(node, a) {\n    const b = node.getBoundingClientRect();\n    if (a.left !== b.left || a.top !== b.top) {\n        const style = getComputedStyle(node);\n        const transform = style.transform === 'none' ? '' : style.transform;\n        node.style.transform = `${transform} translate(${a.left - b.left}px, ${a.top - b.top}px)`;\n    }\n}\n\nlet current_component;\nfunction set_current_component(component) {\n    current_component = component;\n}\nfunction get_current_component() {\n    if (!current_component)\n        throw new Error('Function called outside component initialization');\n    return current_component;\n}\nfunction beforeUpdate(fn) {\n    get_current_component().$$.before_update.push(fn);\n}\nfunction onMount(fn) {\n    get_current_component().$$.on_mount.push(fn);\n}\nfunction afterUpdate(fn) {\n    get_current_component().$$.after_update.push(fn);\n}\nfunction onDestroy(fn) {\n    get_current_component().$$.on_destroy.push(fn);\n}\nfunction createEventDispatcher() {\n    const component = get_current_component();\n    return (type, detail) => {\n        const callbacks = component.$$.callbacks[type];\n        if (callbacks) {\n            // TODO are there situations where events could be dispatched\n            // in a server (non-DOM) environment?\n            const event = custom_event(type, detail);\n            callbacks.slice().forEach(fn => {\n                fn.call(component, event);\n            });\n        }\n    };\n}\nfunction setContext(key, context) {\n    get_current_component().$$.context.set(key, context);\n}\nfunction getContext(key) {\n    return get_current_component().$$.context.get(key);\n}\nfunction getAllContexts() {\n    return get_current_component().$$.context;\n}\nfunction hasContext(key) {\n    return get_current_component().$$.context.has(key);\n}\n// TODO figure out if we still want to support\n// shorthand events, or if we want to implement\n// a real bubbling mechanism\nfunction bubble(component, event) {\n    const callbacks = component.$$.callbacks[event.type];\n    if (callbacks) {\n        // @ts-ignore\n        callbacks.slice().forEach(fn => fn.call(this, event));\n    }\n}\n\nconst dirty_components = [];\nconst intros = { enabled: false };\nconst binding_callbacks = [];\nconst render_callbacks = [];\nconst flush_callbacks = [];\nconst resolved_promise = Promise.resolve();\nlet update_scheduled = false;\nfunction schedule_update() {\n    if (!update_scheduled) {\n        update_scheduled = true;\n        resolved_promise.then(flush);\n    }\n}\nfunction tick() {\n    schedule_update();\n    return resolved_promise;\n}\nfunction add_render_callback(fn) {\n    render_callbacks.push(fn);\n}\nfunction add_flush_callback(fn) {\n    flush_callbacks.push(fn);\n}\nlet flushing = false;\nconst seen_callbacks = new Set();\nfunction flush() {\n    if (flushing)\n        return;\n    flushing = true;\n    do {\n        // first, call beforeUpdate functions\n        // and update components\n        for (let i = 0; i < dirty_components.length; i += 1) {\n            const component = dirty_components[i];\n            set_current_component(component);\n            update(component.$$);\n        }\n        set_current_component(null);\n        dirty_components.length = 0;\n        while (binding_callbacks.length)\n            binding_callbacks.pop()();\n        // then, once components are updated, call\n        // afterUpdate functions. This may cause\n        // subsequent updates...\n        for (let i = 0; i < render_callbacks.length; i += 1) {\n            const callback = render_callbacks[i];\n            if (!seen_callbacks.has(callback)) {\n                // ...so guard against infinite loops\n                seen_callbacks.add(callback);\n                callback();\n            }\n        }\n        render_callbacks.length = 0;\n    } while (dirty_components.length);\n    while (flush_callbacks.length) {\n        flush_callbacks.pop()();\n    }\n    update_scheduled = false;\n    flushing = false;\n    seen_callbacks.clear();\n}\nfunction update($$) {\n    if ($$.fragment !== null) {\n        $$.update();\n        run_all($$.before_update);\n        const dirty = $$.dirty;\n        $$.dirty = [-1];\n        $$.fragment && $$.fragment.p($$.ctx, dirty);\n        $$.after_update.forEach(add_render_callback);\n    }\n}\n\nlet promise;\nfunction wait() {\n    if (!promise) {\n        promise = Promise.resolve();\n        promise.then(() => {\n            promise = null;\n        });\n    }\n    return promise;\n}\nfunction dispatch(node, direction, kind) {\n    node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));\n}\nconst outroing = new Set();\nlet outros;\nfunction group_outros() {\n    outros = {\n        r: 0,\n        c: [],\n        p: outros // parent group\n    };\n}\nfunction check_outros() {\n    if (!outros.r) {\n        run_all(outros.c);\n    }\n    outros = outros.p;\n}\nfunction transition_in(block, local) {\n    if (block && block.i) {\n        outroing.delete(block);\n        block.i(local);\n    }\n}\nfunction transition_out(block, local, detach, callback) {\n    if (block && block.o) {\n        if (outroing.has(block))\n            return;\n        outroing.add(block);\n        outros.c.push(() => {\n            outroing.delete(block);\n            if (callback) {\n                if (detach)\n                    block.d(1);\n                callback();\n            }\n        });\n        block.o(local);\n    }\n}\nconst null_transition = { duration: 0 };\nfunction create_in_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = false;\n    let animation_name;\n    let task;\n    let uid = 0;\n    function cleanup() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);\n        tick(0, 1);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        if (task)\n            task.abort();\n        running = true;\n        add_render_callback(() => dispatch(node, true, 'start'));\n        task = loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(1, 0);\n                    dispatch(node, true, 'end');\n                    cleanup();\n                    return running = false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(t, 1 - t);\n                }\n            }\n            return running;\n        });\n    }\n    let started = false;\n    return {\n        start() {\n            if (started)\n                return;\n            started = true;\n            delete_rule(node);\n            if (is_function(config)) {\n                config = config();\n                wait().then(go);\n            }\n            else {\n                go();\n            }\n        },\n        invalidate() {\n            started = false;\n        },\n        end() {\n            if (running) {\n                cleanup();\n                running = false;\n            }\n        }\n    };\n}\nfunction create_out_transition(node, fn, params) {\n    let config = fn(node, params);\n    let running = true;\n    let animation_name;\n    const group = outros;\n    group.r += 1;\n    function go() {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        if (css)\n            animation_name = create_rule(node, 1, 0, duration, delay, easing, css);\n        const start_time = now() + delay;\n        const end_time = start_time + duration;\n        add_render_callback(() => dispatch(node, false, 'start'));\n        loop(now => {\n            if (running) {\n                if (now >= end_time) {\n                    tick(0, 1);\n                    dispatch(node, false, 'end');\n                    if (!--group.r) {\n                        // this will result in `end()` being called,\n                        // so we don't need to clean up here\n                        run_all(group.c);\n                    }\n                    return false;\n                }\n                if (now >= start_time) {\n                    const t = easing((now - start_time) / duration);\n                    tick(1 - t, t);\n                }\n            }\n            return running;\n        });\n    }\n    if (is_function(config)) {\n        wait().then(() => {\n            // @ts-ignore\n            config = config();\n            go();\n        });\n    }\n    else {\n        go();\n    }\n    return {\n        end(reset) {\n            if (reset && config.tick) {\n                config.tick(1, 0);\n            }\n            if (running) {\n                if (animation_name)\n                    delete_rule(node, animation_name);\n                running = false;\n            }\n        }\n    };\n}\nfunction create_bidirectional_transition(node, fn, params, intro) {\n    let config = fn(node, params);\n    let t = intro ? 0 : 1;\n    let running_program = null;\n    let pending_program = null;\n    let animation_name = null;\n    function clear_animation() {\n        if (animation_name)\n            delete_rule(node, animation_name);\n    }\n    function init(program, duration) {\n        const d = (program.b - t);\n        duration *= Math.abs(d);\n        return {\n            a: t,\n            b: program.b,\n            d,\n            duration,\n            start: program.start,\n            end: program.start + duration,\n            group: program.group\n        };\n    }\n    function go(b) {\n        const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;\n        const program = {\n            start: now() + delay,\n            b\n        };\n        if (!b) {\n            // @ts-ignore todo: improve typings\n            program.group = outros;\n            outros.r += 1;\n        }\n        if (running_program || pending_program) {\n            pending_program = program;\n        }\n        else {\n            // if this is an intro, and there's a delay, we need to do\n            // an initial tick and/or apply CSS animation immediately\n            if (css) {\n                clear_animation();\n                animation_name = create_rule(node, t, b, duration, delay, easing, css);\n            }\n            if (b)\n                tick(0, 1);\n            running_program = init(program, duration);\n            add_render_callback(() => dispatch(node, b, 'start'));\n            loop(now => {\n                if (pending_program && now > pending_program.start) {\n                    running_program = init(pending_program, duration);\n                    pending_program = null;\n                    dispatch(node, running_program.b, 'start');\n                    if (css) {\n                        clear_animation();\n                        animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);\n                    }\n                }\n                if (running_program) {\n                    if (now >= running_program.end) {\n                        tick(t = running_program.b, 1 - t);\n                        dispatch(node, running_program.b, 'end');\n                        if (!pending_program) {\n                            // we're done\n                            if (running_program.b) {\n                                // intro — we can tidy up immediately\n                                clear_animation();\n                            }\n                            else {\n                                // outro — needs to be coordinated\n                                if (!--running_program.group.r)\n                                    run_all(running_program.group.c);\n                            }\n                        }\n                        running_program = null;\n                    }\n                    else if (now >= running_program.start) {\n                        const p = now - running_program.start;\n                        t = running_program.a + running_program.d * easing(p / running_program.duration);\n                        tick(t, 1 - t);\n                    }\n                }\n                return !!(running_program || pending_program);\n            });\n        }\n    }\n    return {\n        run(b) {\n            if (is_function(config)) {\n                wait().then(() => {\n                    // @ts-ignore\n                    config = config();\n                    go(b);\n                });\n            }\n            else {\n                go(b);\n            }\n        },\n        end() {\n            clear_animation();\n            running_program = pending_program = null;\n        }\n    };\n}\n\nfunction handle_promise(promise, info) {\n    const token = info.token = {};\n    function update(type, index, key, value) {\n        if (info.token !== token)\n            return;\n        info.resolved = value;\n        let child_ctx = info.ctx;\n        if (key !== undefined) {\n            child_ctx = child_ctx.slice();\n            child_ctx[key] = value;\n        }\n        const block = type && (info.current = type)(child_ctx);\n        let needs_flush = false;\n        if (info.block) {\n            if (info.blocks) {\n                info.blocks.forEach((block, i) => {\n                    if (i !== index && block) {\n                        group_outros();\n                        transition_out(block, 1, 1, () => {\n                            if (info.blocks[i] === block) {\n                                info.blocks[i] = null;\n                            }\n                        });\n                        check_outros();\n                    }\n                });\n            }\n            else {\n                info.block.d(1);\n            }\n            block.c();\n            transition_in(block, 1);\n            block.m(info.mount(), info.anchor);\n            needs_flush = true;\n        }\n        info.block = block;\n        if (info.blocks)\n            info.blocks[index] = block;\n        if (needs_flush) {\n            flush();\n        }\n    }\n    if (is_promise(promise)) {\n        const current_component = get_current_component();\n        promise.then(value => {\n            set_current_component(current_component);\n            update(info.then, 1, info.value, value);\n            set_current_component(null);\n        }, error => {\n            set_current_component(current_component);\n            update(info.catch, 2, info.error, error);\n            set_current_component(null);\n            if (!info.hasCatch) {\n                throw error;\n            }\n        });\n        // if we previously had a then/catch block, destroy it\n        if (info.current !== info.pending) {\n            update(info.pending, 0);\n            return true;\n        }\n    }\n    else {\n        if (info.current !== info.then) {\n            update(info.then, 1, info.value, promise);\n            return true;\n        }\n        info.resolved = promise;\n    }\n}\nfunction update_await_block_branch(info, ctx, dirty) {\n    const child_ctx = ctx.slice();\n    const { resolved } = info;\n    if (info.current === info.then) {\n        child_ctx[info.value] = resolved;\n    }\n    if (info.current === info.catch) {\n        child_ctx[info.error] = resolved;\n    }\n    info.block.p(child_ctx, dirty);\n}\n\nconst globals = (typeof window !== 'undefined'\n    ? window\n    : typeof globalThis !== 'undefined'\n        ? globalThis\n        : global);\n\nfunction destroy_block(block, lookup) {\n    block.d(1);\n    lookup.delete(block.key);\n}\nfunction outro_and_destroy_block(block, lookup) {\n    transition_out(block, 1, 1, () => {\n        lookup.delete(block.key);\n    });\n}\nfunction fix_and_destroy_block(block, lookup) {\n    block.f();\n    destroy_block(block, lookup);\n}\nfunction fix_and_outro_and_destroy_block(block, lookup) {\n    block.f();\n    outro_and_destroy_block(block, lookup);\n}\nfunction update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {\n    let o = old_blocks.length;\n    let n = list.length;\n    let i = o;\n    const old_indexes = {};\n    while (i--)\n        old_indexes[old_blocks[i].key] = i;\n    const new_blocks = [];\n    const new_lookup = new Map();\n    const deltas = new Map();\n    i = n;\n    while (i--) {\n        const child_ctx = get_context(ctx, list, i);\n        const key = get_key(child_ctx);\n        let block = lookup.get(key);\n        if (!block) {\n            block = create_each_block(key, child_ctx);\n            block.c();\n        }\n        else if (dynamic) {\n            block.p(child_ctx, dirty);\n        }\n        new_lookup.set(key, new_blocks[i] = block);\n        if (key in old_indexes)\n            deltas.set(key, Math.abs(i - old_indexes[key]));\n    }\n    const will_move = new Set();\n    const did_move = new Set();\n    function insert(block) {\n        transition_in(block, 1);\n        block.m(node, next);\n        lookup.set(block.key, block);\n        next = block.first;\n        n--;\n    }\n    while (o && n) {\n        const new_block = new_blocks[n - 1];\n        const old_block = old_blocks[o - 1];\n        const new_key = new_block.key;\n        const old_key = old_block.key;\n        if (new_block === old_block) {\n            // do nothing\n            next = new_block.first;\n            o--;\n            n--;\n        }\n        else if (!new_lookup.has(old_key)) {\n            // remove old block\n            destroy(old_block, lookup);\n            o--;\n        }\n        else if (!lookup.has(new_key) || will_move.has(new_key)) {\n            insert(new_block);\n        }\n        else if (did_move.has(old_key)) {\n            o--;\n        }\n        else if (deltas.get(new_key) > deltas.get(old_key)) {\n            did_move.add(new_key);\n            insert(new_block);\n        }\n        else {\n            will_move.add(old_key);\n            o--;\n        }\n    }\n    while (o--) {\n        const old_block = old_blocks[o];\n        if (!new_lookup.has(old_block.key))\n            destroy(old_block, lookup);\n    }\n    while (n)\n        insert(new_blocks[n - 1]);\n    return new_blocks;\n}\nfunction validate_each_keys(ctx, list, get_context, get_key) {\n    const keys = new Set();\n    for (let i = 0; i < list.length; i++) {\n        const key = get_key(get_context(ctx, list, i));\n        if (keys.has(key)) {\n            throw new Error('Cannot have duplicate keys in a keyed each');\n        }\n        keys.add(key);\n    }\n}\n\nfunction get_spread_update(levels, updates) {\n    const update = {};\n    const to_null_out = {};\n    const accounted_for = { $$scope: 1 };\n    let i = levels.length;\n    while (i--) {\n        const o = levels[i];\n        const n = updates[i];\n        if (n) {\n            for (const key in o) {\n                if (!(key in n))\n                    to_null_out[key] = 1;\n            }\n            for (const key in n) {\n                if (!accounted_for[key]) {\n                    update[key] = n[key];\n                    accounted_for[key] = 1;\n                }\n            }\n            levels[i] = n;\n        }\n        else {\n            for (const key in o) {\n                accounted_for[key] = 1;\n            }\n        }\n    }\n    for (const key in to_null_out) {\n        if (!(key in update))\n            update[key] = undefined;\n    }\n    return update;\n}\nfunction get_spread_object(spread_props) {\n    return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};\n}\n\n// source: https://html.spec.whatwg.org/multipage/indices.html\nconst boolean_attributes = new Set([\n    'allowfullscreen',\n    'allowpaymentrequest',\n    'async',\n    'autofocus',\n    'autoplay',\n    'checked',\n    'controls',\n    'default',\n    'defer',\n    'disabled',\n    'formnovalidate',\n    'hidden',\n    'ismap',\n    'loop',\n    'multiple',\n    'muted',\n    'nomodule',\n    'novalidate',\n    'open',\n    'playsinline',\n    'readonly',\n    'required',\n    'reversed',\n    'selected'\n]);\n\nconst invalid_attribute_name_character = /[\\s'\">/=\\u{FDD0}-\\u{FDEF}\\u{FFFE}\\u{FFFF}\\u{1FFFE}\\u{1FFFF}\\u{2FFFE}\\u{2FFFF}\\u{3FFFE}\\u{3FFFF}\\u{4FFFE}\\u{4FFFF}\\u{5FFFE}\\u{5FFFF}\\u{6FFFE}\\u{6FFFF}\\u{7FFFE}\\u{7FFFF}\\u{8FFFE}\\u{8FFFF}\\u{9FFFE}\\u{9FFFF}\\u{AFFFE}\\u{AFFFF}\\u{BFFFE}\\u{BFFFF}\\u{CFFFE}\\u{CFFFF}\\u{DFFFE}\\u{DFFFF}\\u{EFFFE}\\u{EFFFF}\\u{FFFFE}\\u{FFFFF}\\u{10FFFE}\\u{10FFFF}]/u;\n// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2\n// https://infra.spec.whatwg.org/#noncharacter\nfunction spread(args, classes_to_add) {\n    const attributes = Object.assign({}, ...args);\n    if (classes_to_add) {\n        if (attributes.class == null) {\n            attributes.class = classes_to_add;\n        }\n        else {\n            attributes.class += ' ' + classes_to_add;\n        }\n    }\n    let str = '';\n    Object.keys(attributes).forEach(name => {\n        if (invalid_attribute_name_character.test(name))\n            return;\n        const value = attributes[name];\n        if (value === true)\n            str += ' ' + name;\n        else if (boolean_attributes.has(name.toLowerCase())) {\n            if (value)\n                str += ' ' + name;\n        }\n        else if (value != null) {\n            str += ` ${name}=\"${value}\"`;\n        }\n    });\n    return str;\n}\nconst escaped = {\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;'\n};\nfunction escape(html) {\n    return String(html).replace(/[\"'&<>]/g, match => escaped[match]);\n}\nfunction escape_attribute_value(value) {\n    return typeof value === 'string' ? escape(value) : value;\n}\nfunction escape_object(obj) {\n    const result = {};\n    for (const key in obj) {\n        result[key] = escape_attribute_value(obj[key]);\n    }\n    return result;\n}\nfunction each(items, fn) {\n    let str = '';\n    for (let i = 0; i < items.length; i += 1) {\n        str += fn(items[i], i);\n    }\n    return str;\n}\nconst missing_component = {\n    $$render: () => ''\n};\nfunction validate_component(component, name) {\n    if (!component || !component.$$render) {\n        if (name === 'svelte:component')\n            name += ' this={...}';\n        throw new Error(`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);\n    }\n    return component;\n}\nfunction debug(file, line, column, values) {\n    console.log(`{@debug} ${file ? file + ' ' : ''}(${line}:${column})`); // eslint-disable-line no-console\n    console.log(values); // eslint-disable-line no-console\n    return '';\n}\nlet on_destroy;\nfunction create_ssr_component(fn) {\n    function $$render(result, props, bindings, slots, context) {\n        const parent_component = current_component;\n        const $$ = {\n            on_destroy,\n            context: new Map(context || (parent_component ? parent_component.$$.context : [])),\n            // these will be immediately discarded\n            on_mount: [],\n            before_update: [],\n            after_update: [],\n            callbacks: blank_object()\n        };\n        set_current_component({ $$ });\n        const html = fn(result, props, bindings, slots);\n        set_current_component(parent_component);\n        return html;\n    }\n    return {\n        render: (props = {}, { $$slots = {}, context = new Map() } = {}) => {\n            on_destroy = [];\n            const result = { title: '', head: '', css: new Set() };\n            const html = $$render(result, props, {}, $$slots, context);\n            run_all(on_destroy);\n            return {\n                html,\n                css: {\n                    code: Array.from(result.css).map(css => css.code).join('\\n'),\n                    map: null // TODO\n                },\n                head: result.title + result.head\n            };\n        },\n        $$render\n    };\n}\nfunction add_attribute(name, value, boolean) {\n    if (value == null || (boolean && !value))\n        return '';\n    return ` ${name}${value === true ? '' : `=${typeof value === 'string' ? JSON.stringify(escape(value)) : `\"${value}\"`}`}`;\n}\nfunction add_classes(classes) {\n    return classes ? ` class=\"${classes}\"` : '';\n}\n\nfunction bind(component, name, callback) {\n    const index = component.$$.props[name];\n    if (index !== undefined) {\n        component.$$.bound[index] = callback;\n        callback(component.$$.ctx[index]);\n    }\n}\nfunction create_component(block) {\n    block && block.c();\n}\nfunction claim_component(block, parent_nodes) {\n    block && block.l(parent_nodes);\n}\nfunction mount_component(component, target, anchor, customElement) {\n    const { fragment, on_mount, on_destroy, after_update } = component.$$;\n    fragment && fragment.m(target, anchor);\n    if (!customElement) {\n        // onMount happens before the initial afterUpdate\n        add_render_callback(() => {\n            const new_on_destroy = on_mount.map(run).filter(is_function);\n            if (on_destroy) {\n                on_destroy.push(...new_on_destroy);\n            }\n            else {\n                // Edge case - component was destroyed immediately,\n                // most likely as a result of a binding initialising\n                run_all(new_on_destroy);\n            }\n            component.$$.on_mount = [];\n        });\n    }\n    after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n    const $$ = component.$$;\n    if ($$.fragment !== null) {\n        run_all($$.on_destroy);\n        $$.fragment && $$.fragment.d(detaching);\n        // TODO null out other refs, including component.$$ (but need to\n        // preserve final state?)\n        $$.on_destroy = $$.fragment = null;\n        $$.ctx = [];\n    }\n}\nfunction make_dirty(component, i) {\n    if (component.$$.dirty[0] === -1) {\n        dirty_components.push(component);\n        schedule_update();\n        component.$$.dirty.fill(0);\n    }\n    component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n    const parent_component = current_component;\n    set_current_component(component);\n    const $$ = component.$$ = {\n        fragment: null,\n        ctx: null,\n        // state\n        props,\n        update: noop,\n        not_equal,\n        bound: blank_object(),\n        // lifecycle\n        on_mount: [],\n        on_destroy: [],\n        on_disconnect: [],\n        before_update: [],\n        after_update: [],\n        context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n        // everything else\n        callbacks: blank_object(),\n        dirty,\n        skip_bound: false,\n        root: options.target || parent_component.$$.root\n    };\n    append_styles && append_styles($$.root);\n    let ready = false;\n    $$.ctx = instance\n        ? instance(component, options.props || {}, (i, ret, ...rest) => {\n            const value = rest.length ? rest[0] : ret;\n            if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n                if (!$$.skip_bound && $$.bound[i])\n                    $$.bound[i](value);\n                if (ready)\n                    make_dirty(component, i);\n            }\n            return ret;\n        })\n        : [];\n    $$.update();\n    ready = true;\n    run_all($$.before_update);\n    // `false` as a special case of no DOM component\n    $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n    if (options.target) {\n        if (options.hydrate) {\n            start_hydrating();\n            const nodes = children(options.target);\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.l(nodes);\n            nodes.forEach(detach);\n        }\n        else {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            $$.fragment && $$.fragment.c();\n        }\n        if (options.intro)\n            transition_in(component.$$.fragment);\n        mount_component(component, options.target, options.anchor, options.customElement);\n        end_hydrating();\n        flush();\n    }\n    set_current_component(parent_component);\n}\nlet SvelteElement;\nif (typeof HTMLElement === 'function') {\n    SvelteElement = class extends HTMLElement {\n        constructor() {\n            super();\n            this.attachShadow({ mode: 'open' });\n        }\n        connectedCallback() {\n            const { on_mount } = this.$$;\n            this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n            // @ts-ignore todo: improve typings\n            for (const key in this.$$.slotted) {\n                // @ts-ignore todo: improve typings\n                this.appendChild(this.$$.slotted[key]);\n            }\n        }\n        attributeChangedCallback(attr, _oldValue, newValue) {\n            this[attr] = newValue;\n        }\n        disconnectedCallback() {\n            run_all(this.$$.on_disconnect);\n        }\n        $destroy() {\n            destroy_component(this, 1);\n            this.$destroy = noop;\n        }\n        $on(type, callback) {\n            // TODO should this delegate to addEventListener?\n            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n            callbacks.push(callback);\n            return () => {\n                const index = callbacks.indexOf(callback);\n                if (index !== -1)\n                    callbacks.splice(index, 1);\n            };\n        }\n        $set($$props) {\n            if (this.$$set && !is_empty($$props)) {\n                this.$$.skip_bound = true;\n                this.$$set($$props);\n                this.$$.skip_bound = false;\n            }\n        }\n    };\n}\n/**\n * Base class for Svelte components. Used when dev=false.\n */\nclass SvelteComponent {\n    $destroy() {\n        destroy_component(this, 1);\n        this.$destroy = noop;\n    }\n    $on(type, callback) {\n        const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));\n        callbacks.push(callback);\n        return () => {\n            const index = callbacks.indexOf(callback);\n            if (index !== -1)\n                callbacks.splice(index, 1);\n        };\n    }\n    $set($$props) {\n        if (this.$$set && !is_empty($$props)) {\n            this.$$.skip_bound = true;\n            this.$$set($$props);\n            this.$$.skip_bound = false;\n        }\n    }\n}\n\nfunction dispatch_dev(type, detail) {\n    document.dispatchEvent(custom_event(type, Object.assign({ version: '3.44.2' }, detail), true));\n}\nfunction append_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append(target, node);\n}\nfunction append_hydration_dev(target, node) {\n    dispatch_dev('SvelteDOMInsert', { target, node });\n    append_hydration(target, node);\n}\nfunction insert_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert(target, node, anchor);\n}\nfunction insert_hydration_dev(target, node, anchor) {\n    dispatch_dev('SvelteDOMInsert', { target, node, anchor });\n    insert_hydration(target, node, anchor);\n}\nfunction detach_dev(node) {\n    dispatch_dev('SvelteDOMRemove', { node });\n    detach(node);\n}\nfunction detach_between_dev(before, after) {\n    while (before.nextSibling && before.nextSibling !== after) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction detach_before_dev(after) {\n    while (after.previousSibling) {\n        detach_dev(after.previousSibling);\n    }\n}\nfunction detach_after_dev(before) {\n    while (before.nextSibling) {\n        detach_dev(before.nextSibling);\n    }\n}\nfunction listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {\n    const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];\n    if (has_prevent_default)\n        modifiers.push('preventDefault');\n    if (has_stop_propagation)\n        modifiers.push('stopPropagation');\n    dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });\n    const dispose = listen(node, event, handler, options);\n    return () => {\n        dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });\n        dispose();\n    };\n}\nfunction attr_dev(node, attribute, value) {\n    attr(node, attribute, value);\n    if (value == null)\n        dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });\n    else\n        dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });\n}\nfunction prop_dev(node, property, value) {\n    node[property] = value;\n    dispatch_dev('SvelteDOMSetProperty', { node, property, value });\n}\nfunction dataset_dev(node, property, value) {\n    node.dataset[property] = value;\n    dispatch_dev('SvelteDOMSetDataset', { node, property, value });\n}\nfunction set_data_dev(text, data) {\n    data = '' + data;\n    if (text.wholeText === data)\n        return;\n    dispatch_dev('SvelteDOMSetData', { node: text, data });\n    text.data = data;\n}\nfunction validate_each_argument(arg) {\n    if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {\n        let msg = '{#each} only iterates over array-like objects.';\n        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {\n            msg += ' You can use a spread to convert this iterable into an array.';\n        }\n        throw new Error(msg);\n    }\n}\nfunction validate_slots(name, slot, keys) {\n    for (const slot_key of Object.keys(slot)) {\n        if (!~keys.indexOf(slot_key)) {\n            console.warn(`<${name}> received an unexpected slot \"${slot_key}\".`);\n        }\n    }\n}\n/**\n * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.\n */\nclass SvelteComponentDev extends SvelteComponent {\n    constructor(options) {\n        if (!options || (!options.target && !options.$$inline)) {\n            throw new Error(\"'target' is a required option\");\n        }\n        super();\n    }\n    $destroy() {\n        super.$destroy();\n        this.$destroy = () => {\n            console.warn('Component was already destroyed'); // eslint-disable-line no-console\n        };\n    }\n    $capture_state() { }\n    $inject_state() { }\n}\n/**\n * Base class to create strongly typed Svelte components.\n * This only exists for typing purposes and should be used in `.d.ts` files.\n *\n * ### Example:\n *\n * You have component library on npm called `component-library`, from which\n * you export a component called `MyComponent`. For Svelte+TypeScript users,\n * you want to provide typings. Therefore you create a `index.d.ts`:\n * ```ts\n * import { SvelteComponentTyped } from \"svelte\";\n * export class MyComponent extends SvelteComponentTyped<{foo: string}> {}\n * ```\n * Typing this makes it possible for IDEs like VS Code with the Svelte extension\n * to provide intellisense and to use the component like this in a Svelte file\n * with TypeScript:\n * ```svelte\n * <script lang=\"ts\">\n * \timport { MyComponent } from \"component-library\";\n * </script>\n * <MyComponent foo={'bar'} />\n * ```\n *\n * #### Why not make this part of `SvelteComponent(Dev)`?\n * Because\n * ```ts\n * class ASubclassOfSvelteComponent extends SvelteComponent<{foo: string}> {}\n * const component: typeof SvelteComponent = ASubclassOfSvelteComponent;\n * ```\n * will throw a type error, so we need to separate the more strictly typed class.\n */\nclass SvelteComponentTyped extends SvelteComponentDev {\n    constructor(options) {\n        super(options);\n    }\n}\nfunction loop_guard(timeout) {\n    const start = Date.now();\n    return () => {\n        if (Date.now() - start > timeout) {\n            throw new Error('Infinite loop detected');\n        }\n    };\n}\n\nexport { HtmlTag, HtmlTagHydration, SvelteComponent, SvelteComponentDev, SvelteComponentTyped, SvelteElement, action_destroyer, add_attribute, add_classes, add_flush_callback, add_location, add_render_callback, add_resize_listener, add_transform, afterUpdate, append, append_dev, append_empty_stylesheet, append_hydration, append_hydration_dev, append_styles, assign, attr, attr_dev, attribute_to_object, beforeUpdate, bind, binding_callbacks, blank_object, bubble, check_outros, children, claim_component, claim_element, claim_html_tag, claim_space, claim_svg_element, claim_text, clear_loops, component_subscribe, compute_rest_props, compute_slots, createEventDispatcher, create_animation, create_bidirectional_transition, create_component, create_in_transition, create_out_transition, create_slot, create_ssr_component, current_component, custom_event, dataset_dev, debug, destroy_block, destroy_component, destroy_each, detach, detach_after_dev, detach_before_dev, detach_between_dev, detach_dev, dirty_components, dispatch_dev, each, element, element_is, empty, end_hydrating, escape, escape_attribute_value, escape_object, escaped, exclude_internal_props, fix_and_destroy_block, fix_and_outro_and_destroy_block, fix_position, flush, getAllContexts, getContext, get_all_dirty_from_scope, get_binding_group_value, get_current_component, get_custom_elements_slots, get_root_for_style, get_slot_changes, get_spread_object, get_spread_update, get_store_value, globals, group_outros, handle_promise, hasContext, has_prop, identity, init, insert, insert_dev, insert_hydration, insert_hydration_dev, intros, invalid_attribute_name_character, is_client, is_crossorigin, is_empty, is_function, is_promise, listen, listen_dev, loop, loop_guard, missing_component, mount_component, noop, not_equal, now, null_to_empty, object_without_properties, onDestroy, onMount, once, outro_and_destroy_block, prevent_default, prop_dev, query_selector_all, raf, run, run_all, safe_not_equal, schedule_update, select_multiple_value, select_option, select_options, select_value, self, setContext, set_attributes, set_current_component, set_custom_element_data, set_data, set_data_dev, set_input_type, set_input_value, set_now, set_raf, set_store_value, set_style, set_svg_attributes, space, spread, src_url_equal, start_hydrating, stop_propagation, subscribe, svg_element, text, tick, time_ranges_to_array, to_number, toggle_class, transition_in, transition_out, trusted, update_await_block_branch, update_keyed_each, update_slot, update_slot_base, validate_component, validate_each_argument, validate_each_keys, validate_slots, validate_store, xlink_attr };\n","<script>\n  export let frameRadius = 46;\n</script>\n<svg\n  class=\"Frame\"\n  viewBox=\"0 0 92 92\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <defs>\n  <linearGradient x1=\"50%\" y1=\"0%\" x2=\"50%\" y2=\"100%\" id=\"a\">\n    <stop stop-color=\"var(--gradient-stop1)\" offset=\"0%\" />\n    <stop stop-color=\"var(--gradient-stop2)\" offset=\"100%\" />\n  </linearGradient>\n  </defs>\n  <circle cx=\"46\" cy=\"46\" r=\"{frameRadius}\" stroke=\"none\" fill=\"var(--frame-background)\"/>\n  <circle cx=\"46\" cy=\"46\" r=\"{frameRadius}\" stroke=\"url(#a)\" stroke-width=\"var(--frame-stroke-width)\" fill=\"none\"/>\n</svg>\n\n<style>\n.Frame {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 50%;\n  left: 50%;\n  transform-origin: 50% 50%;\n  transform: translate(-50%, -50%) rotate(var(--fx-rotation));\n  transition: width 0.1s, height 0.1s;\n  pointer-events: none;\n  user-select: none;\n}\n\n</style>",null,null,"<script lang=\"ts\">\n  import {\n    Icon\n  } from \"../constants\";\n\n  export let icon: Icon = Icon.Mic;\n</script>\n\n{#if icon === Icon.MicActive}\n<svg\n  class=\"Icon\"\n  viewBox=\"0 0 56 56\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <linearGradient id=\"gradient\" x1=\"50%\" y1=\"-200%\" x2=\"50%\" y2=\"200%\">\n    <animate attributeName=\"y1\" values=\"-200%; 0%;\" dur=\"2s\" repeatCount=\"indefinite\" />\n    <animate attributeName=\"y2\" values=\"200%; 400%;\" dur=\"2s\" repeatCount=\"indefinite\" />\n    <stop offset=\"0%\" stop-color=\"var(--gradient-stop1)\"></stop>\n    <stop offset=\"25%\" stop-color=\"var(--gradient-stop2)\"></stop>\n    <stop offset=\"50%\" stop-color=\"var(--gradient-stop1)\"></stop>\n    <stop offset=\"75%\" stop-color=\"var(--gradient-stop2)\"></stop>\n    <stop offset=\"100%\" stop-color=\"var(--gradient-stop1)\"></stop>\n  </linearGradient>>\n  <g fill=\"url(#gradient)\" fill-rule=\"evenodd\">\n    <path\n      d=\"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\"\n    />\n    <rect x=\"20\" y=\"1\" width=\"16\" height=\"37\" rx=\"8\" />\n  </g>\n</svg>\n{/if}\n\n{#if icon === Icon.Mic}\n<svg\n  class=\"Icon\"\n  viewBox=\"0 0 56 56\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <g fill=\"var(--icon-color)\" fill-rule=\"evenodd\">\n    <path\n      d=\"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\"\n    />\n    <rect x=\"20\" y=\"1\" width=\"16\" height=\"37\" rx=\"8\" />\n  </g>\n</svg>\n{/if}\n\n{#if icon === Icon.Error}\n<svg class=\"Icon\" viewBox=\"0 0 56 56\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g fill=\"var(--icon-color)\" fill-rule=\"evenodd\">\n    <path\n      d=\"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\"\n      fill-rule=\"nonzero\"\n    />\n    <path d=\"M37 13.081V31a8 8 0 11-16 0v-1.919l16-16zM26 1a8 8 0 018 8v1.319L18 26.318V9a8 8 0 018-8zM37.969 7.932l3.74-7.35 3.018 2.625zM39.654 10.608l7.531-3.359.695 3.94z\" />\n  </g>\n</svg>\n{/if}\n\n{#if icon === Icon.Denied}\n<svg class=\"Icon\" viewBox=\"0 0 56 56\" xmlns=\"http://www.w3.org/2000/svg\">\n  <g fill=\"var(--icon-color)\" fill-rule=\"nonzero\">\n    <path d=\"M36 14.828V30a8 8 0 01-15.961.79l15.96-15.962zM28 1a8 8 0 018 8v.172L20 25.173V9a8 8 0 018-8z\" />\n    <path d=\"M42 26h4v4c0 9.265-7 16.895-16 17.89V55h-4v-7.11c-8.892-.982-15.833-8.444-15.997-17.56L10 30v-4h4v4c0 7.732 6.268 14 14 14 7.628 0 13.83-6.1 13.997-13.687L42 30v-4z\" />\n  </g>\n</svg>\n{/if}\n\n<style>\n  .Icon {\n    position: absolute;\n    width: var(--icon-size);\n    height: var(--icon-size);\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    pointer-events: none;\n    transition: 0.25s;\n    opacity: var(--icon-opacity);\n  }\n\n</style>","<svg\n  class=\"Fx\"\n  viewBox=\"0 0 246 246\"\n  xmlns=\"http://www.w3.org/2000/svg\"\n>\n  <defs>\n    <linearGradient x1=\"50%\" y1=\"10%\" x2=\"50%\" y2=\"100%\" id=\"a\">\n      <stop stop-color=\"var(--fx-gradient-stop1)\" offset=\"0%\" />\n      <stop stop-color=\"var(--fx-gradient-stop2)\" offset=\"100%\" />\n    </linearGradient>\n    <filter\n      x=\"-35%\"\n      y=\"-35%\"\n      width=\"170%\"\n      height=\"170%\"\n      filterUnits=\"objectBoundingBox\"\n      id=\"b\"\n    >\n      <feGaussianBlur stdDeviation=\"18\" in=\"SourceGraphic\" />\n    </filter>\n  </defs>\n  <circle\n    filter=\"url(#b)\"\n    cx=\"124\"\n    cy=\"124\"\n    r=\"79\"\n    fill=\"url(#a)\"\n    fillRule=\"evenodd\"\n  />\n</svg>\n\n<style>\n  .Fx {\n    position: absolute;\n    width: var(--fx-size);\n    height: var(--fx-size);\n    top: 50%;\n    left: 50%;\n    transform-origin: 50% 50%;\n    transform: translate(-50%, -50%) rotate(var(--fx-rotation));\n    pointer-events: none;\n    opacity: var(--fx-opacity);\n  }\n</style>","<svelte:options tag={null} immutable={true} />\n\n<script lang=\"ts\">\n  import { onMount } from \"svelte\";\n  import { get_current_component } from \"svelte/internal\";\n  import MicFrame from \"./components/MicFrame.svelte\";\n  import MicIcon from \"./components/MicIcon.svelte\";\n  import MicFx from \"./components/MicFx.svelte\";\n  import type { IAppearance, IHoldEvent } from \"./types\";\n  import {\n    ClientState,\n    Icon,\n    Effect,\n    Behaviour,\n    MessageType,\n    clientStateToAppearance,\nTriggerFx,\n  } from \"./constants\";\n\n  export let icon = ClientState.Disconnected;\n  export let capturekey = \" \";\n  export let hide = undefined;\n  export let size = \"80px\";\n  export let holdscale = \"1.35\";\n  export let borderscale = \"0.075\";\n  export let iconsize = \"60%\";\n  export let fxsize = \"250%\";\n  export let backgroundcolor = \"#ffffff\";\n  export let iconcolor = \"#000000\";\n  export let gradientstop1 = \"#15e8b5\";\n  export let gradientstop2 = \"#4fa1f9\";\n  export let fxgradientstop1 = undefined\n  export let fxgradientstop2 = undefined\n  export let customcssurl = undefined;\n  export const isbuttonpressed = () => tangentHeld;\n\n  $: visible = hide === undefined || hide === \"false\";\n  $: frameStrokeWidth = `${46 * (borderscale as unknown as number)}`;\n  $: frameRadius = 46 - 23 * (borderscale as unknown as number);\n  $: buttonHeldScale = (holdscale as unknown as number);\n\n  let tangentHeld = false;\n  let holdStartTimestamp = 0;\n  let rotation = [0.0, 0.0];\n  let scale = [0.0, 0.0];\n  let iconOpacity = [1.0, 1.0];\n  let fxOpacity = [0.0, 0.0];\n  let effectiveAppearance: IAppearance = clientStateToAppearance[icon];\n  let timeout = null;\n  let prevFrameMillis = 0;\n  let frameMillis = 0;\n\n  // Run this reactive statement whenever icon parameters (icon) changes\n  $: {\n    updateSkin(tangentHeld, icon);\n  }\n\n  // Prepare a dispatchUnbounded function to communicate outside shadow DOM box. Svelte native dispatchUnbounded won't do that.\n  const thisComponent = get_current_component();\n  const dispatchUnbounded = (name: string, detail?: {}) => {\n    thisComponent.dispatchEvent(\n      new CustomEvent(name, {\n        detail,\n        composed: true, // propagate across the shadow DOM\n      })\n    );\n  };\n\n  onMount(() => {\n    // Transition in button\n    scale = [1, 0];\n\n    let requestId = null;\n\n    const tick = () => {\n      prevFrameMillis = frameMillis;\n      frameMillis = new Date().getTime();\n      const tickMs = frameMillis - (prevFrameMillis || frameMillis);\n\n      if (effectiveAppearance.effect === Effect.Connecting) {\n        // Animate iconOpacity when starting\n        iconOpacity[0] =\n          Math.cos((frameMillis / 2500) * Math.PI * 2) * 0.25 + 0.25;\n      }\n      if (effectiveAppearance.effect === Effect.Busy) {\n        // Animate iconOpacity when tarting\n        iconOpacity[0] =\n          Math.cos((frameMillis / 1000) * Math.PI * 2) * 0.25 + 0.25;\n      }\n\n      scale = [\n        scale[0],\n        animateValue(scale[1], visible ? scale[0] : 0, 0.2, tickMs),\n      ];\n      iconOpacity = [\n        iconOpacity[0],\n        animateValue(iconOpacity[1], iconOpacity[0], 0.08, tickMs),\n      ];\n      fxOpacity = [\n        fxOpacity[0],\n        animateValue(fxOpacity[1], fxOpacity[0], 0.08, tickMs),\n      ];\n      rotation = [\n        rotation[0] + 2.5,\n        animateValue(rotation[1], rotation[0], 0.05, tickMs),\n      ];\n      requestId = requestAnimationFrame(tick);\n    };\n\n    tick();\n\n    return () => cancelAnimationFrame(requestId);\n  });\n\n  const tangentStart = (event) => {\n    event.preventDefault();\n    event.stopPropagation();\n\n    if (visible && !tangentHeld) {\n      tangentHeld = true;\n      holdStartTimestamp = Date.now();\n      vibrate();\n\n      // Play a rotation whirl\n      if (effectiveAppearance.triggerFx === TriggerFx.Whirl) {\n        rotation[0] += 720;\n      }\n\n      // Connect on 1st press\n      if (effectiveAppearance.behaviour === Behaviour.Click) {\n        // Auto-release hold after some time\n        if (timeout === null) {\n          timeout = window.setTimeout(() => {\n            fxOpacity[0] = 0;\n            // scale[0] = 0;\n            // updateSkin();\n            timeout = null;\n          }, 500);\n        }\n      }\n\n      // Trigger callback defined as property\n      if (thisComponent.onholdstart) thisComponent.onholdstart();\n      // Also trigger an event\n      dispatchUnbounded(MessageType.holdstart);\n    }\n  };\n\n  const tangentEnd = () => {\n    if (tangentHeld) {\n      tangentHeld = false;\n      const eventPayload: IHoldEvent = {\n        timeMs: Date.now() - holdStartTimestamp,\n      };\n      vibrate();\n\n      // Cancel any pending auto-release\n      if (timeout !== null) {\n        window.clearTimeout(timeout);\n      }\n\n      // Trigger callback defined as property\n      if (thisComponent.onholdend) thisComponent.onholdend(eventPayload);\n      // Also trigger an event\n      dispatchUnbounded(\"holdend\", eventPayload);\n    }\n  };\n\n  const keyDownCallback = (event) => {\n    if (capturekey) {\n      if (event.key === capturekey) {\n        var focused_element =\n          (document.hasFocus() &&\n            document.activeElement !== document.body &&\n            document.activeElement !== document.documentElement &&\n            document.activeElement) ||\n          null;\n        if (!focused_element) {\n          if (!event.repeat) {\n            tangentStart(event);\n          } else {\n            event.preventDefault();\n            event.stopPropagation();\n          }\n        }\n      }\n    }\n  };\n\n  const keyUpCallBack = (event) => {\n    if (event.key === capturekey) {\n      tangentEnd();\n    }\n  };\n\n  const animateValue = (\n    value: number,\n    target: number,\n    pull: number,\n    tickMs: number\n  ) => {\n    const NOMINAL_FRAME_MILLIS = 1000.0 / 60;\n    pull = Math.pow(pull, NOMINAL_FRAME_MILLIS / tickMs);\n    return value * (1.0 - pull) + target * pull;\n  };\n\n  const vibrate = (durationMs = 5) => {\n    if (navigator.vibrate !== undefined) {\n      navigator.vibrate(durationMs);\n    }\n  };\n\n  const updateSkin = (buttonHeld: boolean, clientState: ClientState) => {\n    effectiveAppearance = clientStateToAppearance[clientState];\n\n    scale[0] = buttonHeld ? buttonHeldScale : 1.0;\n    fxOpacity[0] = (buttonHeld || clientState == ClientState.Recording) ? 1.0 : 0.0;\n\n    switch (effectiveAppearance.icon) {\n      case Icon.MicActive:\n      case Icon.Mic:\n      case Icon.Denied:\n      case Icon.Error:\n        iconOpacity[0] = 1.0;\n        break;\n    }\n  };\n</script>\n\n<svelte:window\n  on:mouseup={tangentEnd}\n  on:keydown={keyDownCallback}\n  on:keyup={keyUpCallBack}\n/>\n\n{#if customcssurl !== undefined}\n  <link href=\"{customcssurl}\" rel=\"stylesheet\">\n{/if}\n\n<main\n  on:mousedown={tangentStart}\n  on:touchstart={tangentStart}\n  on:dragstart={tangentStart}\n  on:mouseup={tangentEnd}\n  on:touchend={tangentEnd}\n  on:dragend={tangentEnd}\n  class=\"HoldableButton\"\n  class:pressed={tangentHeld}\n  style=\"\n    width:{size};\n    height:{size};\n    --gradient-stop1: {gradientstop1};\n    --gradient-stop2: {gradientstop2};\n    --fx-gradient-stop1: {fxgradientstop1 || gradientstop1};\n    --fx-gradient-stop2: {fxgradientstop2 || gradientstop2};\n    --fx-rotation: {rotation[1]}deg;\n    --fx-opacity: {fxOpacity[1]};\n    --fx-size: {fxsize};\n    --icon-opacity: {iconOpacity[1]};\n    --icon-size: {iconsize};\n    --icon-color: {iconcolor};\n    --frame-stroke-width: {frameStrokeWidth};\n    --frame-background: {backgroundcolor};\n    transform: scale({scale[1]});\n  \"\n>\n  <MicFx/>\n  <MicFrame frameRadius={frameRadius}/>\n  <MicIcon\n    icon={effectiveAppearance.icon}\n  />\n  <slot></slot>\n\n</main>\n\n<style>\n\n  main {\n    text-align: left;\n    position: relative;\n    pointer-events: auto;\n    cursor: pointer;\n    border-radius: 50%;\n    -webkit-tap-highlight-color: transparent;\n    -webkit-touch-callout: none !important;\n    -webkit-user-select: none !important;\n  }\n</style>\n",null]},"metadata":{},"sourceType":"script"}